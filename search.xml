<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>浅谈二分</title>
    <url>/2020/06/28/%E6%B5%85%E8%B0%88%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>二分法是用在有序的数据中快速筛选数据的方法。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>关于下界L和上界R，对于数组来说，假设我们新建一个长度为N的数组，用数学上的定义的来说，是[0,N)，左闭右开的区间。决定区间开闭的同时，也决定了搜索的区间和二分的终止条件（没有可以进行搜索的区间），最直接的就是反应在left和right在循环过程中的变化。详细看下面。</p>
<h3 id="code-amp-analysis"><a href="#code-amp-analysis" class="headerlink" title="code &amp; analysis"></a>code &amp; analysis</h3><h5 id="一、标准二分"><a href="#一、标准二分" class="headerlink" title="一、标准二分"></a>一、标准二分</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int binarySearch(int[] nums, int target) &#123;</span><br><span class="line">    int left &#x3D; 0; </span><br><span class="line">    int right &#x3D; nums.length - 1;&#x2F;&#x2F;决定左闭右闭</span><br><span class="line"></span><br><span class="line">    while(left &lt;&#x3D; right) &#123;&#x2F;&#x2F;决定了搜索区间以及二分终止条件</span><br><span class="line">        int mid &#x3D; (right + left) &#x2F; 2;&#x2F;&#x2F;忽略溢出问题</span><br><span class="line">        if(nums[mid] &#x3D;&#x3D; target)</span><br><span class="line">            return mid; </span><br><span class="line">        else if (nums[mid] &lt; target)</span><br><span class="line">            left &#x3D; mid + 1;&#x2F;&#x2F;因为左闭</span><br><span class="line">        else if (nums[mid] &gt; target)</span><br><span class="line">            right &#x3D; mid - 1;&#x2F;&#x2F;因为右闭</span><br><span class="line">        &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标准二分是左闭右闭的区间，搜索区间为[left,right]，注意二分终止的条件是 left &lt;= right，因为终止二分的条件是没有可以进行搜索的区间了，当搜索区间为[right+1,right]，搜索区间为空，终止条件正确。如果写成 left &lt; right ，就会出现当left=2，right=2，则搜索区间为[2,2]，此时搜索区间成立，还需要进行搜索，但二分搜索已经终止，终止条件错误。</p>
<h5 id="二、左闭右开的二分"><a href="#二、左闭右开的二分" class="headerlink" title="二、左闭右开的二分"></a>二、左闭右开的二分</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int binarySearch(int[] nums, int target) &#123;</span><br><span class="line">    int left &#x3D; 0; </span><br><span class="line">    int right &#x3D; nums.length;&#x2F;&#x2F;决定左闭右开</span><br><span class="line"></span><br><span class="line">    while(left &lt; right) &#123;&#x2F;&#x2F;决定了搜索区间以及二分终止条件</span><br><span class="line">        int mid &#x3D; (right + left) &#x2F; 2;&#x2F;&#x2F;忽略溢出问题</span><br><span class="line">        if(nums[mid] &#x3D;&#x3D; target)</span><br><span class="line">            return mid; </span><br><span class="line">        else if (nums[mid] &lt; target)</span><br><span class="line">            left &#x3D; mid + 1;&#x2F;&#x2F;因为左闭</span><br><span class="line">        else if (nums[mid] &gt; target)</span><br><span class="line">            right &#x3D; mid;&#x2F;&#x2F;因为右开</span><br><span class="line">        &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同标准二分一样分析，左闭右开的二分，则搜索区间是[left,right)，二分的终止条件是 left &lt; right ，当搜索区间为[right,right)，搜索区间为空，终止条件正确。注意right = mid的操作，而不是right = mid - 1，因为right初始值为nums.length，这个索引位置是不能访问的，另一个原因是右开，rright要始终遵守赋值为取不到的右边界。</p>
<h5 id="三、重复元素的左界（下界）搜索二分"><a href="#三、重复元素的左界（下界）搜索二分" class="headerlink" title="三、重复元素的左界（下界）搜索二分"></a>三、重复元素的左界（下界）搜索二分</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int left_bound(int[] nums, int target) &#123;</span><br><span class="line">        if (nums.length &#x3D;&#x3D; 0) return -1;</span><br><span class="line">        int left &#x3D; 0;</span><br><span class="line">        int right &#x3D; nums.length;</span><br><span class="line"></span><br><span class="line">        while (left &lt; right) &#123; &#x2F;&#x2F; 注意</span><br><span class="line">            int mid &#x3D; (left + right) &#x2F; 2;</span><br><span class="line">            if (nums[mid] &#x3D;&#x3D; target) &#123;</span><br><span class="line">                right &#x3D; mid;&#x2F;&#x2F;不return，缩小中心点，使得中点向左靠，继续搜索左界</span><br><span class="line">            &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">                left &#x3D; mid + 1;</span><br><span class="line">            &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">                right &#x3D; mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;循环结束时，left的值表示比target小的数有left个</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; target 比所有数都大</span><br><span class="line">        if (left &#x3D;&#x3D; nums.length) return -1;</span><br><span class="line">        &#x2F;&#x2F;处理可能target比所有数都小的情况下left也为0和target为搜不到但处于数组最小值与最大值之间的值的情况</span><br><span class="line">        return nums[left] &#x3D;&#x3D; target ? left : -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>左界二分是当出现重复元素的时候，找到最左值的索引。这里不分析边界的情况，这里主要说明找最左值的时应该知道的知识。在nums[mid] == target时，将right = mid，而不是return，是为了继续往左界搜索。最终得到left表示比target小的数有left个，注意left可能为nums.length，因为一直搜不到，最后mid + 1得到nums.length。因此，根据之前二分搜不到的情况下返回-1，最后程序单独处理一下即可。</p>
<h5 id="四、重复元素的右界（上界）搜索二分"><a href="#四、重复元素的右界（上界）搜索二分" class="headerlink" title="四、重复元素的右界（上界）搜索二分"></a>四、重复元素的右界（上界）搜索二分</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int right_bound(int[] nums, int target) &#123;</span><br><span class="line">        if (nums.length &#x3D;&#x3D; 0) return -1;</span><br><span class="line">        int left &#x3D; 0, right &#x3D; nums.length;</span><br><span class="line"></span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            int mid &#x3D; (left + right) &#x2F; 2;</span><br><span class="line">            if (nums[mid] &#x3D;&#x3D; target) &#123;</span><br><span class="line">                left &#x3D; mid + 1; &#x2F;&#x2F; 搜索上界</span><br><span class="line">            &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">                left &#x3D; mid + 1;</span><br><span class="line">            &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">                right &#x3D; mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;*</span><br><span class="line">        循环结束时，left的值表示比target小的数有left-1个</span><br><span class="line">        减1是因为一直nums[mid]&#x3D;&#x3D;target的时候一直在加1，即使已经是最后一个了</span><br><span class="line">        *&#x2F;</span><br><span class="line"></span><br><span class="line">        if (left &#x3D;&#x3D; 0) return -1;</span><br><span class="line">        return nums[left - 1] &#x3D;&#x3D; target ? left - 1 : -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="溢出处理"><a href="#溢出处理" class="headerlink" title="溢出处理"></a>溢出处理</h3><p>L + R溢出的情况，可以进行转换：（L + R）/ 2 = （2L + R-L）/ 2 = L + （R - L）/ 2，代码中写成 L + ((R - L) &gt;&gt; 1)。</p>
<p>有些时候上面一步的转换并不能避免溢出的问题，这是因为数据范围的问题，无法用数学的方法避免，例如int情况下，使用L + ((R - L) &gt;&gt; 1)还是无法避免溢出是int数据范围导致的计算过程无法规避溢出问题，此时应该使用更大范围的数据类型进行处理，例如先用long进行计算，最后return的时候强转回int。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 121</title>
    <url>/2020/07/20/leetcode-121/</url>
    <content><![CDATA[<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</a></p>
<p>往后的比之前最小的差值即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int maxProfit(int[] prices) &#123;</span><br><span class="line">    int min &#x3D; Integer.MAX_VALUE;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; prices.length; i++) &#123;</span><br><span class="line">        if (prices[i] &lt; min) &#123;</span><br><span class="line">            min &#x3D; prices[i];</span><br><span class="line">        &#125; else if (prices[i] - min &gt; ans) &#123;</span><br><span class="line">            ans &#x3D; prices[i] - min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 122</title>
    <url>/2020/07/20/leetcode-122/</url>
    <content><![CDATA[<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p>
<p>要求买必须在手上没有货的情况下，则求所有单调递增区间，取头尾差值即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int maxProfit(int[] prices) &#123;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    int valley &#x3D; prices[0];</span><br><span class="line">    int peak &#x3D; prices[0];</span><br><span class="line">    int maxprofit &#x3D; 0;</span><br><span class="line">    while (i &lt; prices.length - 1) &#123;</span><br><span class="line">        while (i &lt; prices.length - 1 &amp;&amp; prices[i] &gt;&#x3D; prices[i + 1])</span><br><span class="line">            i++;</span><br><span class="line">        valley &#x3D; prices[i];</span><br><span class="line">        while (i &lt; prices.length - 1 &amp;&amp; prices[i] &lt;&#x3D; prices[i + 1])</span><br><span class="line">            i++;</span><br><span class="line">        peak &#x3D; prices[i];</span><br><span class="line">        maxprofit +&#x3D; peak - valley;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxprofit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>coding技巧，只要后面比之前大，加上差值即可，会凑成每个单调递增区间的差值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int maxProfit(int[] prices) &#123;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; prices.length; i++) &#123;</span><br><span class="line">        if (prices[i] &gt; prices[i - 1]) &#123;</span><br><span class="line">            ans +&#x3D; prices[i] - prices[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 123</title>
    <url>/2020/07/20/leetcode-123/</url>
    <content><![CDATA[<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/</a></p>
<p>股票限定只有两次购买出售，可以转化为找一个分割点i，使得i左右的股票抛售最大。首先，用两个数组左右各横扫一次，第一个数组记录从0到i为止的最大值，第二个数组记录从i到prices.length-1的最大值。左右答案相加即可，在遍历第二个数组的时候已经可以将答案得到，减少一个循环。注意：ans需要初始化为第一个数组的最后一个值，为了应付等差数列，例如1，2，3，4，5，因为我们是用第一个数组的i对应的值加上第二个数组的i+1对应的值，如果是等差数列，则会出现断裂的情况，比预期的值少了一个公差。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int maxProfit(int[] prices) &#123;</span><br><span class="line">    if (prices.length &lt; 2) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int[] preArr &#x3D; new int[prices.length];</span><br><span class="line">    int[] suffArr &#x3D; new int[prices.length];</span><br><span class="line">    preArr[0] &#x3D; 0;</span><br><span class="line">    suffArr[0] &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    int preMin &#x3D; prices[0];</span><br><span class="line">    int suffMax &#x3D; prices[prices.length - 1];</span><br><span class="line">    for (int i &#x3D; 1; i &lt; prices.length; i++) &#123;</span><br><span class="line">        preArr[i] &#x3D; Math.max(preArr[i - 1], prices[i] - preMin);</span><br><span class="line">        preMin &#x3D; Math.min(preMin, prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ans &#x3D; preArr[prices.length - 1];</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; prices.length - 2; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        suffArr[i] &#x3D; Math.max(suffArr[i + 1], suffMax - prices[i]);</span><br><span class="line">        suffMax &#x3D; Math.max(suffMax, prices[i]);</span><br><span class="line">        ans &#x3D; Math.max(ans, preArr[i] + suffArr[i + 1]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更为激进的做法，使用4个变量一次循环，buy代表买入，profit代表收益。buy1表示到当前位置的买入最小值，profit1表示到目前为止能达到的最大收益。buy2是寻找目前为止距离上次产生最大收益后能买入的最低价而且记录了上次产生的最大收益，profit2表示目前为止两次交易能达到的最大收益。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int maxProfit(int[] prices) &#123;</span><br><span class="line">    int buy1 &#x3D; Integer.MAX_VALUE;</span><br><span class="line">    int buy2 &#x3D; Integer.MAX_VALUE;</span><br><span class="line">    int profit1 &#x3D; 0;</span><br><span class="line">    int profit2 &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; prices.length; i++) &#123;</span><br><span class="line">        buy1 &#x3D; Math.min(buy1, prices[i]);</span><br><span class="line">        profit1 &#x3D; Math.max(profit1, prices[i] - buy1);</span><br><span class="line">        buy2 &#x3D; Math.min(buy2, prices[i] - profit1);</span><br><span class="line">        profit2 &#x3D; Math.max(profit2, prices[i] - buy2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return profit2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 188</title>
    <url>/2020/07/20/leetcode-188/</url>
    <content><![CDATA[<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/</a></p>
<p>由于买卖次数不确定，只能用dp做。</p>
<p>状态位表示：</p>
<p>（1）dp[i][yes][j]表示第i天持有股票且历史（包括本次买入）的持有股票数量j；</p>
<p>（2）dp[i][no][j]表示第i天无持有股票且历史（包括本次卖出）的抛售股票数量为j；</p>
<p>则有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;当天持有股票且最大利润的结果为前一天历史持有j只股票与前一天历史抛售j-1只股票后在当天买入的最大值</span><br><span class="line">dp[i][yes][j] &#x3D; max( dp[i-1][yes][j] , dp[i-1][no][j-1] - prices[i] );</span><br><span class="line">&#x2F;&#x2F;当天无持有股票且最大利润的结果为前一天历史抛售j只股票与前一天历史持有j只股票后在当天卖出的最大值</span><br><span class="line">dp[i][no][j] &#x3D; max( dp[i-1][no][j] , dp[i-1][yes][j] + prices[i] );</span><br></pre></td></tr></table></figure>

<p>注意到yes和no这一维其实可以用两个数组就可以降下来，考虑状态位优化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;buy表示当前持有股票状态</span><br><span class="line">buy[i][j] &#x3D; max( buy[i-1][j] , sell[i-1][j-1] - prices[i] );</span><br><span class="line">&#x2F;&#x2F;sell表示当前无持有股票状态</span><br><span class="line">sell[i][j] &#x3D; max( sell[i-1][j] , buy[i-1][j] + prices[i] );</span><br></pre></td></tr></table></figure>
<p>再次观察式子，后一天的状态跟前一天其实是无关的。</p>
<p>（1）对于buy[i][j] = max( buy[i-1][j] , sell[i-1][j-1] - prices[i] )，当前历史持有j只股票只跟前一天的买入和前一天的j-1次买入有关，前一天的j-1很重要，如果是j则需要用数组来copy上一次的sell数组。</p>
<p>（2）对于sell[i][j] = max( sell[i-1][j] , buy[i-1][j] + prices[i] )，当前历史持有j只股票只跟前一天为止卖出了j只股票和包括今天持有股票且历史持有j次有关。而且buy[i-1][j]不可能被上式buy[i][j]的更新影响，因为当天买入股票又卖出股票的情况不会比前一天买入低价当天卖出高价更大。</p>
<p>最终优化为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;此时可以简化buy[j]的意义为交易小于等于j次且手头持有股票时的最大利润</span><br><span class="line">buy[j] &#x3D; Math.max(sell[j - 1] - prices[i], buy[j]);</span><br><span class="line">&#x2F;&#x2F;此时可以简化sell[j]的意义为交易小于等于j次且手头没有股票时的最大利润</span><br><span class="line">sell[j] &#x3D; Math.max(sell[j], buy[j] + prices[i]);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int maxProfit(int k, int[] prices) &#123;</span><br><span class="line">        int len &#x3D; prices.length;</span><br><span class="line">        int ans &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        if (k &gt;&#x3D; (len &gt;&gt; 1)) &#123;</span><br><span class="line">            for (int i &#x3D; 1; i &lt; len; i++) &#123;</span><br><span class="line">                ans +&#x3D; prices[i] &gt; prices[i - 1] ? prices[i] - prices[i - 1] : 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int[] buy &#x3D; new int[k + 1];</span><br><span class="line">            int[] sell &#x3D; new int[k + 1];</span><br><span class="line">            &#x2F;&#x2F;不填充就不买入了，而且必须填充所有的，因为第一天最后无论交易多少次手上只要持有，必定是亏损</span><br><span class="line">            &#x2F;&#x2F;可以用Integer.MIN_VALUE &gt;&gt; 1初始化，除以2是为了防止sell[j - 1] - prices[i]溢出，也可以用意义更为明确的-prices[0]</span><br><span class="line">            Arrays.fill(buy, Integer.MIN_VALUE &gt;&gt; 1);</span><br><span class="line">            &#x2F;&#x2F;可以不填充卖出，有买入才有卖出</span><br><span class="line">            &#x2F;&#x2F;Arrays.fill(sell, Integer.MIN_VALUE &gt;&gt; 1);</span><br><span class="line">            for (int i &#x3D; 1; i &lt; len; i++) &#123;</span><br><span class="line">                for (int j &#x3D; 1; j &lt;&#x3D; k &amp;&amp; j &lt;&#x3D; i; j++) &#123;</span><br><span class="line">                    buy[j] &#x3D; Math.max(sell[j - 1] - prices[i], buy[j]);</span><br><span class="line">                    sell[j] &#x3D; Math.max(sell[j], buy[j] + prices[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;可以不用遍历，可能i在小于k的时候拿到最大值，但是更新i+1的时候会拿i的值比较刷新，因为要保证当前是利润最大的</span><br><span class="line">            &#x2F;&#x2F;或者理解成i+1次的时候可以通过当天买入卖出凑次数，虽然实际上并非如此</span><br><span class="line">            &#x2F;&#x2F;for (int i &#x3D; 0; i &lt;&#x3D; k; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;    ans &#x3D; Math.max(sell[i], ans);</span><br><span class="line">            &#x2F;&#x2F;&#125;</span><br><span class="line">            &#x2F;&#x2F;答案一定在最终卖出的时候取得，如果最后还持有股票，那么一定不会达到最大的利润</span><br><span class="line">            ans &#x3D; sell[k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>二维dp数组写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int maxProfit(int k, int[] prices) &#123;</span><br><span class="line">        int len &#x3D; prices.length;</span><br><span class="line">        int ans &#x3D; 0;</span><br><span class="line">        if(k &gt;&#x3D; (len &gt;&gt; 1)) &#123;</span><br><span class="line">            for(int i &#x3D; 1; i &lt; len; ++i)&#123;</span><br><span class="line">                if(prices[i] &gt; prices[i - 1])&#123;</span><br><span class="line">                    ans +&#x3D; prices[i] - prices[i-1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            int[][] dp &#x3D; new int[2][k + 1];</span><br><span class="line">            Arrays.fill(dp[0], Integer.MIN_VALUE &gt;&gt; 1);</span><br><span class="line">            &#x2F;&#x2F;可用Arrays.fill(dp[0], -prices[0]);</span><br><span class="line"></span><br><span class="line">            for(int i &#x3D; 1; i &lt; len; ++i)&#123;</span><br><span class="line">                for(int j &#x3D; 1; j &lt;&#x3D; k &amp;&amp; j &lt;&#x3D; i; ++j)&#123;</span><br><span class="line">                    dp[0][j] &#x3D; Math.max( dp[0][j] , dp[1][j - 1] - prices[i]);</span><br><span class="line">                    dp[1][j] &#x3D; Math.max( dp[1][j] , dp[0][j] + prices[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;	</span><br><span class="line"></span><br><span class="line">            ans &#x3D; dp[1][k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 309</title>
    <url>/2020/07/20/leetcode-309/</url>
    <content><![CDATA[<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p>
<p>思路：考虑3个状态位，0表示当天手上有股票，1表示当天刚卖掉，2表示当天手上没股票观望中，隔天可以进行交易。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int maxProfit(int[] prices) &#123;</span><br><span class="line">    if(prices.length &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 0 手上有   1 刚卖   2 观望中|手上没有|冷静中</span><br><span class="line">    int[][] dp &#x3D; new int[3][prices.length];</span><br><span class="line">    dp[0][0] &#x3D; -prices[0];</span><br><span class="line">    for(int i &#x3D; 1; i &lt; prices.length; ++i)&#123;</span><br><span class="line">        &#x2F;&#x2F;今天手上有，要么昨天就有，要么昨天观望今天买入</span><br><span class="line">        dp[0][i] &#x3D; Math.max( dp[0][i-1] , dp[2][i-1] - prices[i] );</span><br><span class="line">        &#x2F;&#x2F;今天刚卖一定是昨天有今天卖</span><br><span class="line">        dp[1][i] &#x3D; dp[0][i-1] + prices[i];</span><br><span class="line">        &#x2F;&#x2F;今天观望，要么昨天就在观望，要么昨天刚卖</span><br><span class="line">        dp[2][i] &#x3D; Math.max( dp[2][i-1] , dp[1][i-1] );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return Math.max(dp[1][prices.length - 1] , dp[2][prices.length - 1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>或者我们可以直接考虑两个状态位，0持有，1未持有。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int maxProfit(int[] prices) &#123;</span><br><span class="line">    if(prices.length &lt; 2)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int[][] dp &#x3D; new int[2][prices.length];</span><br><span class="line">    &#x2F;&#x2F;0持有，1手上没股票</span><br><span class="line">    dp[0][0] &#x3D; -prices[0];</span><br><span class="line">    dp[0][1] &#x3D; Math.max(-prices[0],-prices[1]);</span><br><span class="line">    dp[1][1] &#x3D; Math.max(0,prices[1]-prices[0]);</span><br><span class="line">    for(int i &#x3D; 2; i &lt; prices.length ;++i)&#123;</span><br><span class="line">        dp[0][i] &#x3D; Math.max(dp[1][i-2] - prices[i] , dp[0][i-1]);</span><br><span class="line">        dp[1][i] &#x3D; Math.max(dp[1][i-1] , dp[0][i-1] + prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return dp[1][prices.length-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 714</title>
    <url>/2020/07/20/leetcode-714/</url>
    <content><![CDATA[<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</a></p>
<p>思路：<br>（1）当天手上无股票为昨天手上无股票与昨天手上持有股票今天卖出的最大值</p>
<p>（2）当天手上持有股票为昨天手上持有股票与昨天手上无股票今天买入的最大值</p>
<p>（3）小费在买入的时候给或者卖出的时候给都行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int maxProfit(int[] prices, int fee) &#123;</span><br><span class="line">    int cash &#x3D; 0, hold &#x3D; -prices[0];</span><br><span class="line">    for (int i &#x3D; 1; i &lt; prices.length; i++) &#123;</span><br><span class="line">        cash &#x3D; Math.max(cash, hold + prices[i] - fee);</span><br><span class="line">        hold &#x3D; Math.max(hold, cash - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return cash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-11</title>
    <url>/2020/07/24/leetcode-11/</url>
    <content><![CDATA[<h4 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h4><p><a href="https://leetcode.com/problems/zigzag-conversion/solution/container-with-most-water/" target="_blank" rel="noopener">https://leetcode.com/problems/zigzag-conversion/solution/container-with-most-water/</a></p>
<p>给你 <em>n</em> 个非负整数 <em>a</em><sub>1</sub>，<em>a</em><sub>2，</sub>...，<em>a</em><sub>n，</sub>每个数代表坐标中的一个点&nbsp;(<em>i</em>,&nbsp;<em>a<sub>i</sub></em>) 。在坐标内画 <em>n</em> 条垂直线，垂直线 <em>i</em>&nbsp;的两个端点分别为&nbsp;(<em>i</em>,&nbsp;<em>a<sub>i</sub></em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与&nbsp;<em>x</em>&nbsp;轴共同构成的容器可以容纳最多的水。</p>

<p><strong>说明：</strong>你不能倾斜容器，且&nbsp;<em>n</em>&nbsp;的值至少为 2。

<p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="avatar"></p>
<p><small>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</small></p>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49</span><br></pre></td></tr></table></figure>

<h4 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h4><p>面积计算过程中取决于左右两块挡板较低的那个。使用双指针，左右夹击，一直计算最大值，较低的一边往中间收拢即可。</p>
<p>时间复杂度O（n），空间复杂度O（1）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int maxArea(int[] height) &#123;</span><br><span class="line">    if (height.length &lt; 2) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    int l &#x3D; 0;</span><br><span class="line">    int r &#x3D; height.length - 1;</span><br><span class="line">    while (l &lt; r) &#123;</span><br><span class="line">        ans &#x3D; Math.max(ans, (r - l) * Math.min(height[l], height[r]));</span><br><span class="line">        if (height[l] &lt; height[r]) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-4</title>
    <url>/2020/07/24/leetcode-4/</url>
    <content><![CDATA[<h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">https://leetcode.com/problems/median-of-two-sorted-arrays/</a></p>
<p>题目描述：给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。</p>
<p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p>
<p>你可以假设 nums1 和 nums2 不会同时为空。</p>
<h3 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h3><p>简单思路：排序合并成一个大数组，类似归并排序的操作，然后求中位数即可。</p>
<p>时间复杂度O（m + n)，</p>
<p>空间复杂度O（m + n）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;</span><br><span class="line">    int[] newArr &#x3D; new int[nums1.length + nums2.length];</span><br><span class="line"></span><br><span class="line">    int m &#x3D; 0, i &#x3D; 0, j &#x3D; 0;</span><br><span class="line">    while(i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;</span><br><span class="line">        newArr[m++] &#x3D; nums1[i] &lt; nums2[j] ? nums1[i++] : nums2[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(i &lt; nums1.length) &#123;</span><br><span class="line">        newArr[m++] &#x3D; nums1[i++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(j &lt; nums2.length) &#123;</span><br><span class="line">        newArr[m++] &#x3D; nums2[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(newArr.length % 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        return (double)newArr[newArr.length&#x2F;2];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return (newArr[newArr.length&#x2F;2 - 1] + newArr[newArr.length&#x2F;2])&#x2F;2.0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双指针法：类似归并的操作，只是不合成数组，用指针跑即可。</p>
<p>时间复杂度O(m + n)，实际时间复杂度只有O（m + n + 1) / 2），空间复杂度O（1）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;</span><br><span class="line">    int m &#x3D; nums1.length;</span><br><span class="line">    int n &#x3D; nums2.length;</span><br><span class="line">    &#x2F;&#x2F;这里也可以处理一下溢出totalL &#x3D; m + (n - m + 1) &#x2F; 2</span><br><span class="line">    int totalL &#x3D; (m + n + 1) &#x2F; 2;</span><br><span class="line"></span><br><span class="line">    int p1 &#x3D; 0;</span><br><span class="line">    int p2 &#x3D; 0;</span><br><span class="line">    while (p1 &lt; m &amp;&amp; p2 &lt; n &amp;&amp; p1 + p2 &lt; totalL) &#123;</span><br><span class="line">        if (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class="line">            p2++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            p1++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (p1 &lt; m &amp;&amp; p1 + p2 &lt; totalL) &#123;</span><br><span class="line">        p1++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (p2 &lt; n &amp;&amp; p1 + p2 &lt; totalL) &#123;</span><br><span class="line">        p2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int maxLeft1 &#x3D; p1 &#x3D;&#x3D; 0 ? Integer.MIN_VALUE : nums1[p1 - 1];</span><br><span class="line">    int maxLeft2 &#x3D; p2 &#x3D;&#x3D; 0 ? Integer.MIN_VALUE : nums2[p2 - 1];</span><br><span class="line">    int maxRight1 &#x3D; p1 &#x3D;&#x3D; m ? Integer.MAX_VALUE : nums1[p1];</span><br><span class="line">    int maxRight2 &#x3D; p2 &#x3D;&#x3D; n ? Integer.MAX_VALUE : nums2[p2];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;分配律处理溢出 (m + n) % 2 &#x3D; m % 2 + n % 2</span><br><span class="line">    if (m % 2 + n % 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        return Math.max(maxLeft1, maxLeft2);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return (double) (Math.max(maxLeft1, maxLeft2) + Math.min(maxRight1, maxRight2)) &#x2F; 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二分法：用分割线的思路，对于两个数组求中位数，其实就是在找一个中间分割点使得分割点左边的元素与右边元素大致相等（大致是因为数量的奇偶）。根据这个思路，我们尝试对两个数组分别切一刀，使得</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数组1的左边个数 + 数组2的左边个数 ~&#x3D; 数组1的右边个数 + 数组2的右边个数。</span><br></pre></td></tr></table></figure>
<p>考虑到对数组1切的一刀已经能够确定一刀后左右两边剩下的个数了，即能够推出数组2的一刀应该在哪里。假设数组1的长度为m，数组2的长度为n，那么左右两边的个数大致相等的情况下，个数应该为(m+n+1)/2，如果数组1的一刀落在i位置，数组2的一刀落在j位置，j应该满足：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">j &#x3D; (m + n + 1) &#x2F; 2 - i;</span><br></pre></td></tr></table></figure>
<p>如此一来，我们便可以在数组1中进行二分查找，然后根据数量关系在数组2切第二刀，比较两刀左右元素的大小关系来调整二分的缩小方向，最终得到答案。</p>
<p>时间复杂度O(log(min(m,n)))，m为nums1的长度，n为nums2的长度。空间复杂度O（1）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;</span><br><span class="line">    &#x2F;&#x2F;这样可以得到O(log(min(m,n)))的复杂度，因为我们只二分第一个数组</span><br><span class="line">    if (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">        return findMedianSortedArrays(nums2, nums1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int m &#x3D; nums1.length;</span><br><span class="line">    int n &#x3D; nums2.length;</span><br><span class="line">    &#x2F;&#x2F;这里也可以处理一下溢出totalL &#x3D; m + (n - m + 1) &#x2F; 2</span><br><span class="line">    int totalL &#x3D; (m + n + 1) &#x2F; 2;</span><br><span class="line"></span><br><span class="line">    int l &#x3D; 0;</span><br><span class="line">    int r &#x3D; nums1.length - 1;</span><br><span class="line"></span><br><span class="line">    while (l &lt;&#x3D; r) &#123;</span><br><span class="line">        int i &#x3D; l + (r - l) &#x2F; 2;</span><br><span class="line">        int j &#x3D; totalL - i;</span><br><span class="line">        &#x2F;*</span><br><span class="line">        满足的条件是 nums1[i] &gt;&#x3D; nums2[j - 1] &amp;&amp; nums1[i - 1] &lt;&#x3D; nums2[j]</span><br><span class="line">        取反就是 nums1[i] &lt; nums2[j - 1] || nums2[i - 1] &gt; nums1[j]，取其中一个条件即可</span><br><span class="line">        考虑题目条件：两个数组不会同时为空，而且前面已经处理成nums1.length &lt;&#x3D; nums2.length，i - 1有越界风险，采用nums1[i] &lt; nums2[j - 1]</span><br><span class="line">        *&#x2F;</span><br><span class="line">        if (nums1[i] &lt; nums2[j - 1]) &#123;</span><br><span class="line">            l &#x3D; i + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            r &#x3D; i - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int i &#x3D; l;</span><br><span class="line">    int j &#x3D; totalL - i;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;处理切割点落在数组头尾的情况</span><br><span class="line">    int maxLeft1 &#x3D; i &#x3D;&#x3D; 0 ? Integer.MIN_VALUE : nums1[i - 1];</span><br><span class="line">    int maxLeft2 &#x3D; j &#x3D;&#x3D; 0 ? Integer.MIN_VALUE : nums2[j - 1];</span><br><span class="line">    int maxRight1 &#x3D; i &#x3D;&#x3D; m ? Integer.MAX_VALUE : nums1[i];</span><br><span class="line">    int maxRight2 &#x3D; j &#x3D;&#x3D; n ? Integer.MAX_VALUE : nums2[j];</span><br><span class="line">    &#x2F;&#x2F;分配律处理溢出 (m + n) % 2 &#x3D; m % 2 + n % 2</span><br><span class="line">    if (m % 2 + n % 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        return Math.max(maxLeft1, maxLeft2);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return (double) (Math.max(maxLeft1, maxLeft2) + Math.min(maxRight1, maxRight2)) &#x2F; 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归切割法：用舍弃的思想来做。假设数组1中的中点下标为m，数组2中的中点下标为n，比较m-1位置的值与n-1位置的值，如果m-1的位置值较小，则舍弃0到m - 1位置的值，接着继续递归的在2个数组剩下的部分去查找，每次舍弃选中舍弃数组的一半元素。</p>
<p>时间复杂度：O（log（m + n）），<br>空间复杂度：O（1），递归造成的栈开销可以忽略，因为是尾递归。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;</span><br><span class="line">    int len &#x3D; nums1.length + nums2.length;</span><br><span class="line">    if (len % 2 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;找中间的两个求平均值</span><br><span class="line">        int l &#x3D; find(nums1, 0, nums2, 0, len &#x2F; 2);</span><br><span class="line">        int r &#x3D; find(nums1, 0, nums2, 0, len &#x2F; 2 + 1);</span><br><span class="line">        return (l + r) &#x2F; 2.0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return find(nums1, 0, nums2, 0, len &#x2F; 2 + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int find(int[] nums1, int i, int[] nums2, int j, int k) &#123;</span><br><span class="line">    &#x2F;&#x2F;始终取最短的数组，方便处理越界的问题，只需处理一个，用nums.length1 - i是因为数组部分被舍弃了</span><br><span class="line">    if (nums1.length - i &gt; nums2.length - j) &#123;</span><br><span class="line">        return find(nums2, j, nums1, i, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;k为1代表查找第一个元素</span><br><span class="line">    if (k &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果越界了，说明数组1都被舍弃了，直接返回数组2的第一个元素</span><br><span class="line">        if (nums1.length &#x3D;&#x3D; i) &#123;</span><br><span class="line">            return nums2[j];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;没有越界的话，返回两个数组当前开始位置的值最小的那个即可</span><br><span class="line">        return Math.min(nums1[i], nums2[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果k不为1但是数组越界了，数组1被全部舍弃，因为数组是有序的，直接计算数组2剩下的下标</span><br><span class="line">    if (nums1.length &#x3D;&#x3D; i) &#123;</span><br><span class="line">        &#x2F;&#x2F;因为k不是从0开始，而是从1开始，要减1</span><br><span class="line">        return nums2[j + k - 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;新的切割位置，注意处理si的数组越界</span><br><span class="line">    int si &#x3D; Math.min(nums1.length, i + k &#x2F; 2);</span><br><span class="line">    int sj &#x3D; j + k - k &#x2F; 2;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;决定舍弃的数组</span><br><span class="line">    if (nums1[si - 1] &gt; nums2[sj - 1]) &#123;</span><br><span class="line">        return find(nums1, i, nums2, sj, k - (sj - j));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return find(nums1, si, nums2, j, k - (si - i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-6</title>
    <url>/2020/07/24/leetcode-6/</url>
    <content><![CDATA[<h4 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h4><p><a href="https://leetcode.com/problems/zigzag-conversion/solution/z-zi-xing-bian-huan-by-leetcode/" target="_blank" rel="noopener">https://leetcode.com/problems/zigzag-conversion/solution/z-zi-xing-bian-huan-by-leetcode/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</span><br><span class="line"></span><br><span class="line">比如输入字符串为 &quot;LEETCODEISHIRING&quot; 行数为 3 时，排列如下：</span><br><span class="line"></span><br><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br><span class="line">之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;LCIRETOESIIGEDHN&quot;。</span><br><span class="line"></span><br><span class="line">请你实现这个将字符串进行指定行数变换的函数：</span><br><span class="line"></span><br><span class="line">string convert(string s, int numRows);</span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;LEETCODEISHIRING&quot;, numRows &#x3D; 3</span><br><span class="line">输出: &quot;LCIRETOESIIGEDHN&quot;</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;LEETCODEISHIRING&quot;, numRows &#x3D; 4</span><br><span class="line">输出: &quot;LDREOEIIECIHNTSG&quot;</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">L     D     R</span><br><span class="line">E   O E   I I</span><br><span class="line">E C   I H   N</span><br><span class="line">T     S     G</span><br></pre></td></tr></table></figure>

<h4 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h4><p>观察一下排列，第一行和最后一行每个元素之间相差(numRows - 1) * 2，其他行之间每个元素交替相差distance = (numRows - 1) * 2 - i * 2和(numRows - 1) * 2 - distance。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L     D     R</span><br><span class="line">E   O E   I I</span><br><span class="line">E C   I H   N</span><br><span class="line">T     S     G</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String convert(String s, int numRows) &#123;</span><br><span class="line">    if (numRows &lt; 2) &#123;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder ans &#x3D; new StringBuilder();</span><br><span class="line">    int maxDistance &#x3D; (numRows - 1) * 2;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; numRows; ++i) &#123;</span><br><span class="line">        int distance &#x3D; i &#x3D;&#x3D; 0 || i &#x3D;&#x3D; numRows - 1 ? maxDistance : maxDistance - i * 2;</span><br><span class="line">        int idx &#x3D; i;</span><br><span class="line">        while (idx &lt; s.length()) &#123;</span><br><span class="line">            ans.append(s.charAt(idx));</span><br><span class="line">            idx +&#x3D; distance;</span><br><span class="line">            if (distance !&#x3D; maxDistance) &#123;</span><br><span class="line">                distance &#x3D; maxDistance - distance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-42</title>
    <url>/2020/07/27/leetcode-42/</url>
    <content><![CDATA[<p><a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="noopener">https://leetcode.com/problems/trapping-rain-water/</a></p>
<p>题目描述：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><img src="http://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="avatar"></p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>

<p>dp思路分析：对于输入的高度数组height，处于i位置的点，设maxLeft[i]是从最左边到i位置为止最高的点，maxRight[i]是从最右边位置到i为止最高的点，它所能承接的雨水是min(maxLeft, maxRight) - height[i]。<br>这里暴力的话，时间复杂度达到n^2，通过预处理，左右各横扫一次，得到最大的值。</p>
<p>时间复杂度O(n)，空间复杂度O(n)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int trap(int[] height) &#123;</span><br><span class="line">    int len &#x3D; height.length;</span><br><span class="line">    if (len &lt; 2) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    int maxLeft[] &#x3D; new int[len];</span><br><span class="line">    int maxRight[] &#x3D; new int[len];</span><br><span class="line"></span><br><span class="line">    maxLeft[0] &#x3D; height[0];</span><br><span class="line">    for (int i &#x3D; 1; i &lt; len - 1; ++i) &#123;</span><br><span class="line">        maxLeft[i] &#x3D; Math.max(maxLeft[i - 1], height[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    maxRight[len - 1] &#x3D; height[len - 1];</span><br><span class="line">    for (int i &#x3D; len - 2; i &gt; 0; --i) &#123;</span><br><span class="line">        maxRight[i] &#x3D; Math.max(maxRight[i + 1], height[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 1; i &lt; len - 1; ++i) &#123;</span><br><span class="line">        ans +&#x3D; Math.min(maxLeft[i], maxRight[i]) - height[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的可以优化一下，因为最后遍历累加答案的时候，可以顺便处理maxLeft，即maxLeft不是一个数组而是一个处理到i位置为止最大的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int trap(int[] height) &#123;</span><br><span class="line">    int len &#x3D; height.length;</span><br><span class="line">    if (len &lt; 2) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    int maxRight[] &#x3D; new int[len];</span><br><span class="line">    maxRight[len - 1] &#x3D; height[len - 1];</span><br><span class="line">    for (int i &#x3D; len - 2; i &gt; 0; --i) &#123;</span><br><span class="line">        maxRight[i] &#x3D; Math.max(maxRight[i + 1], height[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int maxLeft &#x3D; height[0];</span><br><span class="line">    for (int i &#x3D; 1; i &lt; len - 1; ++i) &#123;</span><br><span class="line">        maxLeft &#x3D; Math.max(maxLeft, height[i]);</span><br><span class="line">        ans +&#x3D; Math.min(maxLeft, maxRight[i]) - height[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单调栈思路分析：对于位置i，i位置所能接的最大雨水取决于左右大中，最低的那个；使用单调递减栈，当出现递增的时候，开始结算雨水，采取每个位置结算多层雨水，累加得到答案。这种方式比较直观，类似模拟从左往右倒水的过程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int trap(int[] height) &#123;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; height.length; ++i) &#123;</span><br><span class="line">        while (!stack.empty() &amp;&amp; height[stack.peek()] &lt; height[i]) &#123;</span><br><span class="line">            int top &#x3D; stack.pop();</span><br><span class="line">            if (stack.empty()) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            ans +&#x3D; (Math.min(height[stack.peek()], height[i]) - height[top]) * (i - stack.peek() - 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双指针思路：使用左右指针，类似dp的思路，当前位置所能更新的最大值是左右中最高中最低那个减去当前高度。具体是左右指针向中间靠拢，靠拢的过程中维护更新左右的最大值。每次，我们从左右中挑选高度较低那边的指针进行遍历，如果高度比维护的最大值更大就更新，否则就接雨水，累加答案。</p>
<p>时间复杂度O(n)，空间复杂度O(1)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int trap(int[] height) &#123;</span><br><span class="line">    if (height.length &lt; 2) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    int maxLeft &#x3D; 0;</span><br><span class="line">    int maxRight &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    int left &#x3D; 0;</span><br><span class="line">    int right &#x3D; height.length - 1;</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        if (height[left] &lt; height[right]) &#123;</span><br><span class="line">            if (height[left] &gt;&#x3D; maxLeft) &#123;</span><br><span class="line">                maxLeft &#x3D; height[left];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ans +&#x3D; maxLeft - height[left];</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (height[right] &gt;&#x3D; maxRight) &#123;</span><br><span class="line">                maxRight &#x3D; height[right];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ans +&#x3D; maxRight - height[right];</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-15</title>
    <url>/2020/07/28/leetcode-15/</url>
    <content><![CDATA[<h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p><a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">https://leetcode.com/problems/3sum/</a></p>
<p>给你一个包含 <em>n</em> 个整数的数组&nbsp;<code>nums</code>，判断&nbsp;<code>nums</code>&nbsp;中是否存在三个元素 <em>a，b，c ，</em>使得&nbsp;<em>a + b + c = </em>0 ？请你找出所有满足条件且不重复的三元组。</p>

<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>

<p><strong>示例：</strong></p>

<pre>给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
</pre>

<h3 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h3><p>暴力的话O（n<sup>3</sup>）。超过O（n<sup>2</sup>）的时候，我们就可以考虑排序了 XD，因为一般的排序算法不会超过O（n<sup>2</sup>）。如果是排序后的数组，那么我们可以考虑指针来做。使用两次循环组合前两个数，再使用一个尾指针初始化指向数组末尾，如果尾指针指向位置的值加上循环组合的两个数超过0，则尾指针向前移动，枚举所有的答案。可以搜索剪枝一下，枚举区间的最大值小于0和枚举区间的最大值大于0的时候就可以不搜了。</p>
<p>时间复杂度O（n<sup>2</sup>），空间复杂度O（log（n）），主要是排序时造成的空间复杂度。</p>
<h3 id="三、code"><a href="#三、code" class="headerlink" title="三、code"></a>三、code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    if (nums.length &lt; 3) &#123;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    int n &#x3D; nums.length;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n - 2; ++i) &#123;</span><br><span class="line">        &#x2F;&#x2F;搜索区间最小值大于0就不搜了，而且因为排序了，后续的所有三数之和都比当前最小值要大，直接结束</span><br><span class="line">        if (nums[i] + nums[i + 1] + nums[i + 2] &gt; 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;搜索区间最大值小于0就不搜了</span><br><span class="line">        if (nums[i] + nums[n - 1] + nums[n - 2] &lt; 0) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;重复的要剔除</span><br><span class="line">        if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int r &#x3D; n - 1;</span><br><span class="line">        for (int j &#x3D; i + 1; j &lt; r; ++j) &#123;</span><br><span class="line">            &#x2F;&#x2F;搜索区间最小值大于0就不搜了，而且因为排序了，后续的所有三数之和都比当前最小值要大，直接结束</span><br><span class="line">            if (nums[i] + nums[j] + nums[j + 1] &gt; 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;搜索区间最大值小于0就不搜了</span><br><span class="line">            if (nums[i] + nums[j] + nums[n - 1] &lt; 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;重复的要剔除</span><br><span class="line">            if (j &gt; i + 1 &amp;&amp; nums[j] &#x3D;&#x3D; nums[j - 1]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;结果太大，尾指针往回走</span><br><span class="line">            while (j &lt; r &amp;&amp; nums[i] + nums[j] + nums[r] &gt; 0) &#123;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;不可能第二个数和第三个数同时使用同一个数，有点类似数组越界</span><br><span class="line">            if (j &#x3D;&#x3D; r) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;组合答案</span><br><span class="line">            if (nums[i] + nums[j] + nums[r] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                List&lt;Integer&gt; subAns &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">                subAns.add(nums[i]);</span><br><span class="line">                subAns.add(nums[j]);</span><br><span class="line">                subAns.add(nums[r]);</span><br><span class="line">                ans.add(subAns);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、复杂度分析"><a href="#四、复杂度分析" class="headerlink" title="四、复杂度分析"></a>四、复杂度分析</h3><p>时间复杂度：最惨就是O（n<sup>2</sup>），两层循环，但是有搜索剪枝优化，总体小于O（n<sup>2</sup>）。</p>
<p>空间复杂度：O（1）。</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-84</title>
    <url>/2020/07/27/leetcode-84/</url>
    <content><![CDATA[<h4 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h4><p><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">https://leetcode.com/problems/largest-rectangle-in-histogram/</a></p>
<p>题目描述：给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<h4 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h4><p>维护一个单调递增栈，从左往右扫一次，对于扫到位置的element，如果element大于等于栈顶的值就压栈；否则，逐个弹出栈顶的值，直到element大于等于栈顶的值，弹栈过程中，更新矩形最大值。为了最后一次也能做计算，我们需要在最后多压一个 -1 入栈，因为 -1 小于所有数组的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int largestRectangleArea(int[] heights) &#123;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">    int[] heightss &#x3D; new int[heights.length + 1];</span><br><span class="line">    System.arraycopy(heights, 0, heightss, 0, heights.length);</span><br><span class="line">    heightss[heights.length] &#x3D; -1;</span><br><span class="line"></span><br><span class="line">    int top &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; heightss.length; ++i) &#123;</span><br><span class="line">        if (stack.empty() || heightss[stack.peek()] &lt;&#x3D; heightss[i]) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            while (!stack.empty() &amp;&amp; heightss[stack.peek()] &gt; heightss[i]) &#123;</span><br><span class="line">                top &#x3D; stack.pop();</span><br><span class="line">                ans &#x3D; Math.max(ans, (i - top) * heightss[top]);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 不能用 stack.push(i)来代替下面两行，会破坏(i - top) * heightss[top]的计算</span><br><span class="line">            stack.push(top);</span><br><span class="line">            heightss[top] &#x3D; heightss[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-258</title>
    <url>/2020/07/30/leetcode-258/</url>
    <content><![CDATA[<h4 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h4><p><a href="https://leetcode.com/problems/add-digits/" target="_blank" rel="noopener">https://leetcode.com/problems/add-digits/</a></p>
<p>给定一个数，求所有位上相加的和，循环上面的操作直到和为一个一位数，例如99 = 9 + 9 = 18 = 1 + 8 = 9。</p>
<h4 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h4><p>利用数学推导，一个10的倍数求最高位的数可以用 % 9来操作，例如70，70 % 9 = 7。</p>
<p>如果给定的数需要循环相加的次数为1，那么71给出题目中的答案就是70 % 9 + 1，可以表示成70 % 9 + 1 % 9，使用结合律化成71 % 9。</p>
<p>如果给定的数需要循环相加的数超过1次，我们可以继续推导，例如88 = 80 % 9 + 8 % 9 = 16 = 10 % 9 + 6 % 9 = 7，可以看出每次循环的相加操作都是%9，对于一个数num来说，num % 9 % 9 … = num % 9。于是本题变成了 % 9即可，但是要考虑9的倍数的情况，例如num = 9。利用分配律，num % 9 = (1 + num - 1) % 9 = 1 + (num - 1) % 9。</p>
<p>多位数的情况也是一样的，假如一个数有n位，每一位上的数分别是an,an-1…a1，则答案就是(an * 10 ^ <sup>n</sup>) % 9 + （an-1 * 10 <sup>n-1</sup>） % 9 + … + a1 % 9。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int addDigits(int num) &#123;</span><br><span class="line">        return 1 + (num - 1) % 9;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-7</title>
    <url>/2020/07/30/leetcode-7/</url>
    <content><![CDATA[<h4 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h4><p><a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-integer/</a></p>
<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。注意溢出时返回0。</p>
<h4 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h4><p>直接取余累加反转即可。注意处理溢出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int reverse(int x) &#123;</span><br><span class="line">    long ans &#x3D; 0;</span><br><span class="line">    while (x !&#x3D; 0) &#123;</span><br><span class="line">        ans &#x3D; ans * 10 + x % 10;</span><br><span class="line">        x &#x2F;&#x3D; 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans &gt; 0x7fffffff || ans &lt; 0x80000000 ? 0 : (int) ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>溢出的其他处理方式：<br>值与Integer.MAX_VALUE/10和Interger.MIN_VALUE/10进行比较，还有 x%10 与 7 和 x%10 与 -8的比较。</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-16</title>
    <url>/2020/08/06/leetcode-16/</url>
    <content><![CDATA[<h4 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h4><p><a href="https://leetcode.com/problems/3sum-closest/" target="_blank" rel="noopener">https://leetcode.com/problems/3sum-closest/</a></p>
<p>给定一个包括&nbsp;<em>n</em> 个整数的数组&nbsp;<code>nums</code><em>&nbsp;</em>和 一个目标值&nbsp;<code>target</code>。找出&nbsp;<code>nums</code><em>&nbsp;</em>中的三个整数，使得它们的和与&nbsp;<code>target</code>&nbsp;最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>

<p>&nbsp;</p>

<p><strong>示例：</strong></p>

<pre><strong>输入：</strong>nums = [-1,2,1,-4], target = 1
<strong>输出：</strong>2
<strong>解释：</strong>与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>3 &lt;= nums.length &lt;= 10^3</code></li>
    <li><code>-10^3&nbsp;&lt;= nums[i]&nbsp;&lt;= 10^3</code></li>
    <li><code>-10^4&nbsp;&lt;= target&nbsp;&lt;= 10^4</code></li>
</ul>

<h4 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h4><p>暴力的话，时间复杂度O（n<sup>3</sup>），与leetcode15类似，使用双指针。设答案为ans，枚举到的三数和为sum，比较abs(ans - target)与abs(sum - target)，更新答案。枚举的过程如下：</p>
<p>设第一个数为i，第二个数为j，初始值为j +  1，第三个数为k，初始值为nums.length - 1，遍历i，j与k是指针，当sum &lt;= target时更新j，当sum &gt; target时更新k。能如此更新j和k是因为，对于单调递增的数组，如果sum &lt;= target，sum只能尝试变得更大去接近target，同理，sum &gt; target，sum只能尝试变得更小去接近target。</p>
<p>优化点：j更新前，如果与后面的元素相等可以跳过，因为j + 1位置的值肯定是已经参与更新过最佳答案，同理k更新前，如果与前面的元素相等也可以跳过。</p>
<p>时间复杂度O（n<sup>2</sup>），空间复杂度O（log（n）），主要是排序时造成的空间复杂度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int threeSumClosest(int[] nums, int target) &#123;</span><br><span class="line">    int n &#x3D; nums.length;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    int ans &#x3D; Integer.MAX_VALUE &#x2F; 2;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; ++i) &#123;</span><br><span class="line">        &#x2F;&#x2F;重复的要剔除</span><br><span class="line">        if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int j &#x3D; i + 1;</span><br><span class="line">        int k &#x3D; n - 1;</span><br><span class="line">        while (j &lt; k) &#123;</span><br><span class="line">            int sum &#x3D; nums[i] + nums[j] + nums[k];</span><br><span class="line">            if (sum &#x3D;&#x3D; target) &#123;</span><br><span class="line">                return sum;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;比较距离更新最大值</span><br><span class="line">            if (Math.abs(sum - target) &lt; Math.abs(ans - target)) &#123;</span><br><span class="line">                ans &#x3D; sum;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (sum &gt; target) &#123;</span><br><span class="line">                &#x2F;&#x2F;相等的先跳过</span><br><span class="line">                while (j &lt; k &amp;&amp; nums[k] &#x3D;&#x3D; nums[k - 1]) &#123;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;更新到第一个不相等的值</span><br><span class="line">                k--;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;相等的先跳过</span><br><span class="line">                while (j &lt; k &amp;&amp; nums[j] &#x3D;&#x3D; nums[j + 1]) &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;更新到第一个不相等的值</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-10</title>
    <url>/2020/08/24/leetcode-10/</url>
    <content><![CDATA[<h4 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h4><p><a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">https://leetcode.com/problems/regular-expression-matching/</a></p>
<p>给你一个字符串&nbsp;<code>s</code>&nbsp;和一个字符规律&nbsp;<code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code>&nbsp;和&nbsp;<code>&#39;*&#39;</code>&nbsp;的正则表达式匹配。</p>

<pre>&#39;.&#39; 匹配任意单个字符
&#39;*&#39; 匹配零个或多个前面的那一个元素
</pre>

<p>所谓匹配，是要涵盖&nbsp;<strong>整个&nbsp;</strong>字符串&nbsp;<code>s</code>的，而不是部分字符串。</p>

<p><strong>说明:</strong></p>

<ul>
    <li><code>s</code>&nbsp;可能为空，且只包含从&nbsp;<code>a-z</code>&nbsp;的小写字母。</li>
    <li><code>p</code>&nbsp;可能为空，且只包含从&nbsp;<code>a-z</code>&nbsp;的小写字母，以及字符&nbsp;<code>.</code>&nbsp;和&nbsp;<code>*</code>。</li>
</ul>

<p><strong>示例 1:</strong></p>

<pre><strong>输入:</strong>
s = &quot;aa&quot;
p = &quot;a&quot;
<strong>输出:</strong> false
<strong>解释:</strong> &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。
</pre>

<p><strong>示例 2:</strong></p>

<pre><strong>输入:</strong>
s = &quot;aa&quot;
p = &quot;a*&quot;
<strong>输出:</strong> true
<strong>解释:</strong>&nbsp;因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。
</pre>

<p><strong>示例&nbsp;3:</strong></p>

<pre><strong>输入:</strong>
s = &quot;ab&quot;
p = &quot;.*&quot;
<strong>输出:</strong> true
<strong>解释:</strong>&nbsp;&quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。
</pre>

<p><strong>示例 4:</strong></p>

<pre><strong>输入:</strong>
s = &quot;aab&quot;
p = &quot;c*a*b&quot;
<strong>输出:</strong> true
<strong>解释:</strong>&nbsp;因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。
</pre>

<p><strong>示例 5:</strong></p>

<pre><strong>输入:</strong>
s = &quot;mississippi&quot;
p = &quot;mis*is*p*.&quot;
<strong>输出:</strong> false</pre>


<h4 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h4><p>采用动态规划。假设以f[i][j]表示s字符串前i个字符能否与p字符串前j个字符相匹配。</p>
<p>（1）如果j位置是字母，则直接匹配是否相等，如果相等，f[i][j]更新为f[i - 1][j - 1]，因为之前也要全都匹配上嘛。</p>
<p>（2）如果j位置的值是 “.” ，直接放过，f[i][j]更新为f[i - 1][j - 1]，理由同（1）。</p>
<p>（3）如果j位置的值是 “*“，考虑一下匹配规则，”*“ 是匹配零个或多个前面的那一个元素，如果我们暴力的去枚举这个结果，有点麻烦。我们换个思路，字符 + * 匹配的过程中只会出现两种情况（注意与上面不同，此时比较的字符串位置是i与j - 1，j - 1是因为需要取 “*“ 前面那个字符）：</p>
<p>（i）匹配字符成功，将最后一个字符舍弃，f[i][j]更新为f[i - 1][j] or f[i][j - 2]。</p>
<p>f[i - 1][j]是舍弃s[i]字符，举个例子，如下所示，因为s[i] 与 p[j - 1]匹配上了，此时如果舍弃s[i]需要满足 s 字符串前 i - 1 个字符与 p 字符串前 j 个字符都匹配上。这里的 j 可能不太好理解，带入下面的例子，cdcc与cdc<em>能够匹配上，所以 i 位置的c字母可以被舍弃。舍弃的角度是从p字符串出发的，因为c\</em>能匹配0个或者任意多个，所以s字符串有多个相同的字母的时候就可以看成舍弃了。</p>
<p>其实当做是扩充匹配也行，cdccc的 i - 1位置的c字母与p字符串 j - 1位置的c字母能匹配，而且 i 位置的c字母与p字符串 j - 1位置的c字母能匹配，说明 i - 1 位置的字母与 i 位置的字母一样。如果cdcc与cdc*能匹配，那么cdccc与cdc*也能匹配上。这里理解成舍弃是因为下面还有一个舍弃的例子，为了理解一致。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cdccca</span><br><span class="line">    i</span><br><span class="line">cdc*a</span><br><span class="line">   j</span><br></pre></td></tr></table></figure>


<p>f[i][j - 2]是舍弃p[j - 1]和p[j]两个字符，因为是字母 + 星号，要整体舍弃，举个例子，如下所示，因为s[i]与p[j-1]匹配上了，此时如果舍弃p[j - 1]和p[j]，需要满足 s 字符串前 i 个字符和 p 字符串前 j - 2 个字符都匹配上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cdccca</span><br><span class="line">    i</span><br><span class="line"></span><br><span class="line">cdcccc*a</span><br><span class="line">      j</span><br></pre></td></tr></table></figure>


<p>（ii）匹配字符失败就是说这个字符不能要，字母 + 星号一起舍弃，f[i][j]更新为f[i][j - 2]</p>
<h4 id="三、code"><a href="#三、code" class="headerlink" title="三、code"></a>三、code</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean isMatch(String s, String p) &#123;</span><br><span class="line">    int m &#x3D; s.length() + 1;</span><br><span class="line">    int n &#x3D; p.length() + 1;</span><br><span class="line">    boolean[][] find &#x3D; new boolean[m][n];</span><br><span class="line">    &#x2F;&#x2F;根据对f的定义，f[0][0]是最初空字符的位置</span><br><span class="line">    find[0][0] &#x3D; true;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j &#x3D; 1; j &lt; n; j++) &#123;</span><br><span class="line">            &#x2F;&#x2F; &quot;*&quot; 的逻辑处理</span><br><span class="line">            if (p.charAt(j - 1) &#x3D;&#x3D; &#39;*&#39;) &#123;</span><br><span class="line">                find[i][j] &#x3D; match(s, p, i, j - 1) ? find[i - 1][j] || find[i][j - 2] : find[i][j - 2];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; &quot;.&quot; 与 字母 的逻辑处理</span><br><span class="line">                find[i][j] &#x3D; match(s, p, i, j) &amp;&amp; find[i - 1][j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return find[m - 1][n - 1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean match(String s, String p, int i, int j) &#123;</span><br><span class="line">    &#x2F;&#x2F; i &#x3D; 0 不用处理，是空字符串的位置，是 &quot;.&quot; 或者相同的字母就是匹配上了</span><br><span class="line">    return i !&#x3D; 0 &amp;&amp; (p.charAt(j - 1) &#x3D;&#x3D; &#39;.&#39; || s.charAt(i - 1) &#x3D;&#x3D; p.charAt(j - 1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、复杂度分析"><a href="#四、复杂度分析" class="headerlink" title="四、复杂度分析"></a>四、复杂度分析</h4><p>时间复杂度：O（m * n），m、n为字符串s、p的长度。</p>
<p>空间复杂度：O（m * n），因为要存储所有的状态。</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-16</title>
    <url>/2020/08/06/leetcode-23/</url>
    <content><![CDATA[<h4 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h4><p><a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-k-sorted-lists/</a></p>
<p>给你一个链表数组，每个链表都已经按升序排列。</p>

<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>lists = [[1,4,5],[1,3,4],[2,6]]
<strong>输出：</strong>[1,1,2,3,4,4,5,6]
<strong>解释：</strong>链表数组如下：
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
将它们合并到一个有序链表中得到。
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>lists = []
<strong>输出：</strong>[]
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>lists = [[]]
<strong>输出：</strong>[]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>k == lists.length</code></li>
    <li><code>0 &lt;= k &lt;= 10^4</code></li>
    <li><code>0 &lt;= lists[i].length &lt;= 500</code></li>
    <li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li>
    <li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li>
    <li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li>
</ul>

<h4 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h4><p>分治法，类似归并排序，逐步的合并两个链表即可。</p>
<h4 id="三、code"><a href="#三、code" class="headerlink" title="三、code"></a>三、code</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode mergeKLists(ListNode[] lists) &#123;</span><br><span class="line">    return merge(lists, 0, lists.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ListNode mergeTowListNode(ListNode l1, ListNode l2) &#123;</span><br><span class="line">    if (l1 &#x3D;&#x3D; null || l2 &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return l1 !&#x3D; null ? l1 : l2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode head &#x3D; new ListNode(-1);</span><br><span class="line">    ListNode temp &#x3D; head;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;合并</span><br><span class="line">    while (l1 !&#x3D; null &amp;&amp; l2 !&#x3D; null) &#123;</span><br><span class="line">        if (l1.val &lt; l2.val) &#123;</span><br><span class="line">            temp.next &#x3D; l1;</span><br><span class="line">            l1 &#x3D; l1.next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            temp.next &#x3D; l2;</span><br><span class="line">            l2 &#x3D; l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp &#x3D; temp.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;因为只剩一个链表，直接拼接即可</span><br><span class="line">    temp.next &#x3D; l1 !&#x3D; null ? l1 : l2;</span><br><span class="line"></span><br><span class="line">    return head.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ListNode merge(ListNode[] lists, int l, int r) &#123;</span><br><span class="line">    if (l &#x3D;&#x3D; r) &#123;</span><br><span class="line">        return lists[l];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;处理空数组</span><br><span class="line">    if (l &gt; r) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int mid &#x3D; l + ((r - l) &gt;&gt; 1);</span><br><span class="line">    return mergeTowListNode(merge(lists, l, mid), merge(lists, mid + 1, r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="四、复杂度分析"><a href="#四、复杂度分析" class="headerlink" title="四、复杂度分析"></a>四、复杂度分析</h4><p>时间复杂度：O（kn * log(k)），类似归并排序，设n为所有链表的平均长度，类似二叉树一样看归并，则kn为每层归并需要排序的元素，log(k)为树高，相乘即为时间复杂度。</p>
<p>空间复杂度：O（log(k)），树高就是空间复杂度，压栈所花费的空间。</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-25</title>
    <url>/2020/09/08/leetcode-25/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p><a href="https://leetcode.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-nodes-in-k-group/</a></p>
<p>给你一个链表，每&nbsp;<em>k&nbsp;</em>个节点一组进行翻转，请你返回翻转后的链表。</p>

<p><em>k&nbsp;</em>是一个正整数，它的值小于或等于链表的长度。</p>

<p>如果节点总数不是&nbsp;<em>k&nbsp;</em>的整数倍，那么请将最后剩余的节点保持原有顺序。</p>

<p>&nbsp;</p>

<p><strong>示例：</strong></p>

<p>给你这个链表：<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>

<p>当&nbsp;<em>k&nbsp;</em>= 2 时，应当返回: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>

<p>当&nbsp;<em>k&nbsp;</em>= 3 时，应当返回: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>

<p>&nbsp;</p>

<p><strong>说明：</strong></p>

<ul>
    <li>你的算法只能使用常数的额外空间。</li>
    <li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际进行节点交换。</li>
</ul>

<h3 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h3><p>反转k个结点，尾结点指向下k个结点的头结点，递归或者迭代处理都可以，递归会有函数压栈的空间消耗，不太满足题意。</p>
<h3 id="三、code"><a href="#三、code" class="headerlink" title="三、code"></a>三、code</h3><p>递归</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode reverseKGroup(ListNode head, int k) &#123;</span><br><span class="line">    if (head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 循环后得到的tail是下一轮循环的开始结点，k个数，k-1次next指向到末尾，k次next指向到末尾的下一个结点</span><br><span class="line">     * 所以reverse函数需要处理的是左闭右开的情况</span><br><span class="line">     *&#x2F;</span><br><span class="line">    ListNode tail &#x3D; head;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">        if (tail &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tail &#x3D; tail.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;反转k个结点得到最前的结点</span><br><span class="line">    ListNode pre &#x3D; reverse(head, tail);</span><br><span class="line">    &#x2F;&#x2F;head经过反转是最后一个结点，下一个结点拼接后面返回后续链表的最前结点</span><br><span class="line">    head.next &#x3D; reverseKGroup(tail, k);</span><br><span class="line"></span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ListNode reverse(ListNode head, ListNode tail) &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * pre是head的前一个结点，初始化为null是为了处理最后一个结点的下一个结点应该为null的情况</span><br><span class="line">     * 写成tail也行，但是写成tail的意义不一样，这样会连接下一段链表，但是意义不大，后续链表还会交换，还要重新连接</span><br><span class="line">     *&#x2F;</span><br><span class="line">    ListNode pre &#x3D; null;</span><br><span class="line">    ListNode next &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F;判断条件是左闭右开</span><br><span class="line">    while (head !&#x3D; tail) &#123;</span><br><span class="line">        next &#x3D; head.next;</span><br><span class="line">        head.next &#x3D; pre;</span><br><span class="line">        pre &#x3D; head;</span><br><span class="line">        head &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode reverseKGroup(ListNode head, int k) &#123;</span><br><span class="line">    ListNode newHead &#x3D; new ListNode(-1);</span><br><span class="line">    newHead.next &#x3D; head;</span><br><span class="line">    &#x2F;&#x2F;pre的作用是作为每一组头结点的前驱结点，为了反转后把上一组的尾结点指向下一组新的头结点</span><br><span class="line">    ListNode pre &#x3D; newHead;</span><br><span class="line"></span><br><span class="line">    while (head !&#x3D; null) &#123;</span><br><span class="line">        ListNode tail &#x3D; pre;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; k; ++i) &#123;</span><br><span class="line">            tail &#x3D; tail.next;</span><br><span class="line">            if (tail &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return newHead.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 反转k个结点</span><br><span class="line">         * 注意虽然是传引用，但是里面不是改变对象的属性，而是直接改变了句柄，不会改变head和tail的指向</span><br><span class="line">         * 反转后head是尾结点，tail是头结点</span><br><span class="line">         *&#x2F;</span><br><span class="line">        reverse(head, tail);</span><br><span class="line">        &#x2F;&#x2F;pre后驱要从指向head改为tail，因为反转后tail是头</span><br><span class="line">        pre.next &#x3D; tail;</span><br><span class="line">        &#x2F;&#x2F;pre更新为下一组头的前驱结点</span><br><span class="line">        pre &#x3D; head;</span><br><span class="line">        &#x2F;&#x2F;head指向下一组的头结点</span><br><span class="line">        head &#x3D; head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return newHead.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void reverse(ListNode head, ListNode tail) &#123;</span><br><span class="line">    &#x2F;&#x2F;初始化为下一组的头结点，为了先接上后面的链表</span><br><span class="line">    ListNode pre &#x3D; tail.next;</span><br><span class="line">    ListNode next &#x3D; null;</span><br><span class="line">    while (pre !&#x3D; tail) &#123;</span><br><span class="line">        next &#x3D; head.next;</span><br><span class="line">        head.next &#x3D; pre;</span><br><span class="line">        pre &#x3D; head;</span><br><span class="line">        head &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、复杂度分析"><a href="#四、复杂度分析" class="headerlink" title="四、复杂度分析"></a>四、复杂度分析</h3><h4 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h4><p>时间复杂度：O（n），遍历一次，加上处理反转时的遍历，也是2n，量级依旧是n。</p>
<p>空间复杂度：O（n/k），函数压栈的空间消耗。</p>
<h4 id="迭代："><a href="#迭代：" class="headerlink" title="迭代："></a>迭代：</h4><p>时间复杂度：O（n），遍历一次，加上处理反转时的遍历，也是2n，量级依旧是n。</p>
<p>空间复杂度：O（1）。</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-26</title>
    <url>/2020/09/08/leetcode-26/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-duplicates-from-sorted-array/</a></p>
<p>给定一个排序数组，你需要在<strong><a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank"> 原地</a></strong> 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>

<p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank">原地 </a>修改输入数组 </strong>并在使用 O(1) 额外空间的条件下完成。</p>

<p>&nbsp;</p>

<p><strong>示例&nbsp;1:</strong></p>

<pre>给定数组 <em>nums</em> = <strong>[1,1,2]</strong>, 

函数应该返回新的长度 <strong>2</strong>, 并且原数组 <em>nums </em>的前两个元素被修改为 <strong><code>1</code></strong>, <strong><code>2</code></strong>。 

你不需要考虑数组中超出新长度后面的元素。</pre>

<p><strong>示例&nbsp;2:</strong></p>

<pre>给定<em> nums </em>= <strong>[0,0,1,1,1,2,2,3,3,4]</strong>,

函数应该返回新的长度 <strong>5</strong>, 并且原数组 <em>nums </em>的前五个元素被修改为 <strong><code>0</code></strong>, <strong><code>1</code></strong>, <strong><code>2</code></strong>, <strong><code>3</code></strong>, <strong><code>4</code></strong>。

你不需要考虑数组中超出新长度后面的元素。
</pre>

<p>&nbsp;</p>

<p><strong>说明:</strong></p>

<p>为什么返回数值是整数，但输出的答案是数组呢?</p>

<p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>

<p>你可以想象内部操作如下:</p>

<pre>// <strong>nums</strong> 是以&ldquo;引用&rdquo;方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中<strong>该长度范围内</strong>的所有元素。
for (int i = 0; i &lt; len; i++) {
&nbsp; &nbsp; print(nums[i]);
}
</pre>

<h3 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h3><p>返回的答案也就是要修改值的下标，注意coding技巧即可。</p>
<h3 id="三、code"><a href="#三、code" class="headerlink" title="三、code"></a>三、code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    int len &#x3D; nums.length;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; ++i) &#123;</span><br><span class="line">        if (i &#x3D;&#x3D; 0 || nums[i] !&#x3D; nums[i - 1]) &#123;</span><br><span class="line">            nums[ans++] &#x3D; nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、复杂度分析"><a href="#四、复杂度分析" class="headerlink" title="四、复杂度分析"></a>四、复杂度分析</h3><p>时间复杂度：O（n），遍历数组的复杂度。</p>
<p>空间复杂度：O（1）。</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-17</title>
    <url>/2020/09/10/leetcode-17/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">原题链接</a></p>
<p>给定一个仅包含数字&nbsp;<code>2-9</code>&nbsp;的字符串，返回所有它能表示的字母组合。</p>

<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>

<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png" style="width: 200px;"></p>

<p><strong>示例:</strong></p>

<pre><strong>输入：</strong>&quot;23&quot;
<strong>输出：</strong>[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].
</pre>

<p><strong>说明:</strong><br>
尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>

<h3 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h3><p>递归的拼接字符即可，注意coding技巧，空间能省则省。</p>
<h3 id="三、code"><a href="#三、code" class="headerlink" title="三、code"></a>三、code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; ans;</span><br><span class="line"></span><br><span class="line">public List&lt;String&gt; letterCombinations(String digits) &#123;</span><br><span class="line">    ans &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    if (digits.length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;不用哈希表，用数组更省空间</span><br><span class="line">    String[] strArr &#x3D; new String[]&#123;&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;;</span><br><span class="line">    char[] digitsArr &#x3D; digits.toCharArray();</span><br><span class="line">    char[] subAns &#x3D; new char[digitsArr.length];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;递归拼接</span><br><span class="line">    recursive(strArr, digitsArr, 0, subAns);</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void recursive(String[] strArr, char[] digitsArr, int idx, char[] subAns) &#123;</span><br><span class="line">    if (idx &#x3D;&#x3D; digitsArr.length) &#123;</span><br><span class="line">        &#x2F;&#x2F;保存答案</span><br><span class="line">        ans.add(String.valueOf(subAns));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;因为手机键盘的字母是从2开始，减掉即可</span><br><span class="line">    String s &#x3D; strArr[digitsArr[idx] - &#39;0&#39; - 2];</span><br><span class="line">    for (int i &#x3D; 0, len &#x3D; s.length(); i &lt; len; ++i) &#123;</span><br><span class="line">        subAns[idx] &#x3D; s.charAt(i);</span><br><span class="line">        recursive(strArr, digitsArr, idx + 1, subAns);</span><br><span class="line">        &#x2F;&#x2F;一般递归在回溯的时候是要做回退操作的，对应本题这里是删除字符操作，但是因为答案已经保存，后续直接覆盖当前位置即可</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、复杂度分析"><a href="#四、复杂度分析" class="headerlink" title="四、复杂度分析"></a>四、复杂度分析</h3><p>时间复杂度：O（4<sup>n</sup>），偷个懒，按每个按键都是4个算吧，n为输入字符的长度。</p>
<p>空间复杂度：O（n）,辅助数组固定26开销，常数级可忽略，主要的空间开销是递归时的栈帧开销，最多为输入字符串的长度n。</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-28</title>
    <url>/2020/09/10/leetcode-28/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p><a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="noopener">https://leetcode.com/problems/implement-strstr/</a></p>
<h3 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h3><p>rabin karp，一种滑动窗口的做法，一直复用之前的计算，使得时间复杂度降低。考虑一下字符的ASCII码，先计算haystack字符串起始位置起needle长度的哈希值，哈希算法使用质数相乘，反复循环needle长度最后得到哈希值。此后，再次移动的时候只要减去第一位字符ASCII码的“偏移计算值”再加上新字符的字符的ASCII码即可。</p>
<h3 id="三、code"><a href="#三、code" class="headerlink" title="三、code"></a>三、code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int strStr(String haystack, String needle) &#123;</span><br><span class="line">        if (needle.length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (haystack.length() &lt; needle.length()) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        char[] haystackArr &#x3D; haystack.toCharArray();</span><br><span class="line">        char[] needleArr &#x3D; needle.toCharArray();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;使用质数，减少哈希冲突</span><br><span class="line">        long primeNumber &#x3D; 31;</span><br><span class="line">        long haystackHash &#x3D; 0;</span><br><span class="line">        long needleHash &#x3D; 0;</span><br><span class="line">        long pow &#x3D; 1;</span><br><span class="line">        long mod &#x3D; Long.MAX_VALUE &gt;&gt; 1;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; needleArr.length; ++i) &#123;</span><br><span class="line">            haystackHash &#x3D; haystackHash * primeNumber + (haystackArr[i] - &#39;\0&#39;);</span><br><span class="line">            haystackHash %&#x3D; mod;</span><br><span class="line">            needleHash &#x3D; needleHash * primeNumber + (needleArr[i] - &#39;\0&#39;);</span><br><span class="line">            needleHash %&#x3D; mod;</span><br><span class="line">            pow *&#x3D; primeNumber % mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (haystackHash &#x3D;&#x3D; needleHash &amp;&amp; haystack.substring(0, needle.length()).equals(needle)) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 1; i &lt; haystackArr.length - needleArr.length + 1; ++i) &#123;</span><br><span class="line">            haystackHash &#x3D; (haystackHash * primeNumber - (haystackArr[i - 1] - &#39;\0&#39;) * pow) + (haystackArr[i + needle.length() - 1] - &#39;\0&#39;);</span><br><span class="line">            haystackHash %&#x3D; mod;</span><br><span class="line">            &#x2F;&#x2F;以防万一，处理哈希冲突</span><br><span class="line">            if (haystackHash &#x3D;&#x3D; needleHash &amp;&amp; haystack.substring(i, i + needle.length()).equals(needle)) &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、复杂度分析"><a href="#四、复杂度分析" class="headerlink" title="四、复杂度分析"></a>四、复杂度分析</h3><p>时间复杂度：O（n），遍历一次，每个字符只参与一次计算。</p>
<p>空间复杂度：O（1）。</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-18</title>
    <url>/2020/09/11/leetcode-18/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p><a href="https://leetcode.com/problems/4sum/" target="_blank" rel="noopener">原题链接</a></p>
<p>给定一个包含&nbsp;<em>n</em> 个整数的数组&nbsp;<code>nums</code>&nbsp;和一个目标值&nbsp;<code>target</code>，判断&nbsp;<code>nums</code>&nbsp;中是否存在四个元素 <em>a，</em><em>b，c</em>&nbsp;和 <em>d</em>&nbsp;，使得&nbsp;<em>a</em> + <em>b</em> + <em>c</em> + <em>d</em>&nbsp;的值与&nbsp;<code>target</code>&nbsp;相等？找出所有满足条件且不重复的四元组。</p>

<p><strong>注意：</strong></p>

<p>答案中不可以包含重复的四元组。</p>

<p><strong>示例：</strong></p>

<pre>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

满足要求的四元组集合为：
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
</pre>

<h3 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h3><p>跟<a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">三数之和</a>一样的做法。</p>
<h3 id="三、code"><a href="#三、code" class="headerlink" title="三、code"></a>三、code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F; 没有4个数就bye bye</span><br><span class="line">    if (nums.length &lt; 4) &#123;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 排序一下</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    int len &#x3D; nums.length;</span><br><span class="line">    int left &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; i为第一个数</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len - 3; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F;最小值大于target说明后面不会再可能枚举到4个值之和等于target</span><br><span class="line">        if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;重复的结果需要去重</span><br><span class="line">        if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;最大值小于target说明这个区间怎么枚举4个值之和都不可能等于target</span><br><span class="line">        if (nums[i] + nums[len - 1] + nums[len - 2] + nums[len - 3] &lt; target) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int j &#x3D; i + 1; j &lt; len - 2; j++) &#123;</span><br><span class="line">            &#x2F;&#x2F;最小值大于target说明后面不会再可能枚举到4个值之和等于target</span><br><span class="line">            if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &gt; target) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;去重</span><br><span class="line">            if (j &gt; i + 1 &amp;&amp; nums[j] &#x3D;&#x3D; nums[j - 1]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;最大值小于target说明这个区间怎么枚举4个值之和都不可能等于target</span><br><span class="line">            if (nums[i] + nums[j] + nums[len - 1] + nums[len - 2] &lt; target) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int k &#x3D; j + 1;</span><br><span class="line">            int l &#x3D; len - 1;</span><br><span class="line">            while (k &lt; l) &#123;</span><br><span class="line">                int sum &#x3D; nums[i] + nums[j] + nums[k] + nums[l];</span><br><span class="line">                if (sum &#x3D;&#x3D; target) &#123;</span><br><span class="line">                    List&lt;Integer&gt; subAns &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">                    subAns.add(nums[i]);</span><br><span class="line">                    subAns.add(nums[j]);</span><br><span class="line">                    subAns.add(nums[k]);</span><br><span class="line">                    subAns.add(nums[l]);</span><br><span class="line">                    ans.add(subAns);</span><br><span class="line">                    while (k &lt; l &amp;&amp; nums[k] &#x3D;&#x3D; nums[++k]) ;</span><br><span class="line">                    while (k &lt; l &amp;&amp; nums[l] &#x3D;&#x3D; nums[--l]) ;</span><br><span class="line">                &#125; else if (sum &lt; target) &#123;</span><br><span class="line">                    while (k &lt; l &amp;&amp; nums[k] &#x3D;&#x3D; nums[++k]) ;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    while (k &lt; l &amp;&amp; nums[l] &#x3D;&#x3D; nums[--l]) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、复杂度分析"><a href="#四、复杂度分析" class="headerlink" title="四、复杂度分析"></a>四、复杂度分析</h3><p>时间复杂度：最惨就是O（n<sup>3</sup>），两层循环加上一次区间枚举，但是有搜索剪枝优化，总体小于O（n<sup>3</sup>）。</p>
<p>空间复杂度：O（1）。</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-94</title>
    <url>/2020/09/14/leetcode-94/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">原题链接</a></p>
<h3 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h3><p>中序遍历是左中右，通过栈模拟即可。</p>
<h3 id="三、code"><a href="#三、code" class="headerlink" title="三、code"></a>三、code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">    List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Deque&lt;TreeNode&gt; stack &#x3D; new ArrayDeque&lt;&gt;();</span><br><span class="line">    while (root !&#x3D; null || !stack.isEmpty()) &#123;</span><br><span class="line">        while (root !&#x3D; null) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root &#x3D; root.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root &#x3D; stack.pop();</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        root &#x3D; root.right;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、复杂度分析"><a href="#四、复杂度分析" class="headerlink" title="四、复杂度分析"></a>四、复杂度分析</h3><p>时间复杂度：O（n），每个结点只会被访问一次。</p>
<p>空间复杂度：O（n），空间复杂度取决于栈最多压入的元素，最差是单链表的情况。</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-239</title>
    <url>/2020/09/18/leetcode-239/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p><a href="https://leetcode.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">原题链接</a></p>
<h3 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h3><p>使用单调队列。队列存的元素是单调递增的，队头保存的是当前窗口的最大值。每次走到i位置的时候，当i位置的元素减去队头元素的位置不小于k，删除队头的元素，如果进来的元素大于等于队尾的元素，删除队尾的元素，大于删掉是为了维护单调性，等于是因为重复了可以直接剔除，不剔除也行。</p>
<h3 id="三、code"><a href="#三、code" class="headerlink" title="三、code"></a>三、code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">        int len &#x3D; nums.length;</span><br><span class="line">        &#x2F;&#x2F;最后返回的只有len - k + 1个</span><br><span class="line">        int[] ans &#x3D; new int[len - k + 1];</span><br><span class="line">        Deque&lt;Integer&gt; q &#x3D; new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; ++i) &#123;</span><br><span class="line">            &#x2F;&#x2F;清理到只剩k-1个</span><br><span class="line">            while (!q.isEmpty() &amp;&amp; i - q.peekFirst() &gt;&#x3D; k) &#123;</span><br><span class="line">                q.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;此时进来的大于等于末尾的也要清末尾的，因为不是最大的，前面一步决定了区间</span><br><span class="line">            while (!q.isEmpty() &amp;&amp; nums[q.peekLast()] &lt;&#x3D; nums[i]) &#123;</span><br><span class="line">                q.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;添加到队尾</span><br><span class="line">            q.addLast(i);</span><br><span class="line"></span><br><span class="line">            if (i &gt;&#x3D; k - 1) &#123;</span><br><span class="line">                ans[i - k + 1] &#x3D; nums[q.peekFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、复杂度分析"><a href="#四、复杂度分析" class="headerlink" title="四、复杂度分析"></a>四、复杂度分析</h3><p>时间复杂度：O（n），只遍历一次。</p>
<p>空间复杂度：O（k），辅助使用的队列最多使用空间是k。</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>aop</title>
    <url>/2020/09/22/aop/</url>
    <content><![CDATA[<p>aop概念：Aspect Oriented Programming，可以翻译成面向切面编程。</p>
<p>aop基础：aop是使用代理模式，通过反射技术动态的在运行时植入代码（定义切面，植入运行时代码）。动态植入的代码与被植入的代码段之间可以理解成是通过桥梁连接生成的，相比于继承体系的实现更加的解耦。</p>
<p>常见的aop应用：日志收集，权限校验等。</p>
<p>spring中的aop：定义了前置通知（before），后置通知（afterReturning），最终通知（after），异常通知（exception），环绕通知（Around)。方法执行顺序如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                doBefore();&#x2F;&#x2F;对应@Before注解的方法切面逻辑  </span><br><span class="line">                method.invoke();</span><br><span class="line">            &#125;finally&#123;</span><br><span class="line">                doAfter();&#x2F;&#x2F;对应@After注解的方法切面逻辑  </span><br><span class="line">            &#125;</span><br><span class="line">            doAfterReturning();&#x2F;&#x2F;对应@AfterReturning注解的方法切面逻辑  </span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            doAfterThrowing();&#x2F;&#x2F;对应@AfterThrowing注解的方法切面逻辑  </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这段代码缺少了环绕通知，环绕通知是更为强大，可以重新定义上述的顺序，一般写了环绕通知就不需要再写其他的通知，统一管理。</p>
<p>基于注解的aop通知类AopLog，位于com.aop，注解里面的表达式是配置对哪些方法进行作用对，这里配置成拦截所有public的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.aop;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.*;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component(&quot;log&quot;)</span><br><span class="line">@Aspect</span><br><span class="line">public class AopLog &#123;</span><br><span class="line">    static long startTime &#x3D; 0;</span><br><span class="line">    static long endTime &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;execution(public * *(..))&quot;)</span><br><span class="line">    public void before() &#123;</span><br><span class="line">        System.out.println(&quot;前置通知&quot;);</span><br><span class="line">        startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterReturning(pointcut &#x3D; &quot;execution(public * *(..))&quot;)</span><br><span class="line">    public void afterReturn() &#123;</span><br><span class="line">        System.out.println(&quot;后置通知&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After(&quot;execution(public * *(..))&quot;)</span><br><span class="line">    public void after() &#123;</span><br><span class="line">        System.out.println(&quot;最终通知&quot;);</span><br><span class="line">        endTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(startTime);</span><br><span class="line">        System.out.println(endTime);</span><br><span class="line">        System.out.println(&quot;耗时&quot; + (endTime - startTime) + &quot;毫秒&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterThrowing(&quot;execution(public * *(..))&quot;)</span><br><span class="line">    public void myException() &#123;</span><br><span class="line">        System.out.println(&quot;异常&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;execution(public * *(..))&quot;)</span><br><span class="line">    public Object around(ProceedingJoinPoint pjp) &#123;</span><br><span class="line">        Object result &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;可以在这里写入请求参数日志</span><br><span class="line">            System.out.println(&quot;before&quot;);</span><br><span class="line">            startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">            &#x2F;&#x2F;目标方法的执行</span><br><span class="line">            result &#x3D; pjp.proceed();</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            &#x2F;&#x2F;可以在这里写入异常日志</span><br><span class="line">            System.out.println(&quot;exception&quot;);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F;可以在这里统计接口耗时</span><br><span class="line">            System.out.println(&quot;after&quot;);</span><br><span class="line">            endTime &#x3D; System.currentTimeMillis();</span><br><span class="line">            System.out.println(startTime);</span><br><span class="line">            System.out.println(endTime);</span><br><span class="line">            System.out.println(&quot;耗时&quot; + (endTime - startTime) + &quot;毫秒&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>People类，位于com.bean，使用aop拦截print方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.bean;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component(&quot;people&quot;)</span><br><span class="line">public class People &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print(String res)&#123;</span><br><span class="line">        &#x2F;&#x2F;测试异常</span><br><span class="line">&#x2F;&#x2F;        int a &#x3D; 1&#x2F;0;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>applicationContext.xml配置文件，配置IOC和AOP等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd</span><br><span class="line">&quot;&gt;</span><br><span class="line">    &lt;!--开启AOP--&gt;</span><br><span class="line">    &lt;aop:aspectj-autoproxy&gt;&lt;&#x2F;aop:aspectj-autoproxy&gt;</span><br><span class="line">    &lt;!--指定IOC容器的扫描包--&gt;</span><br><span class="line">    &lt;context:component-scan base-package&#x3D;&quot;com.aop,com.bean&quot;&gt;&lt;&#x2F;context:component-scan&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.bean.People;</span><br><span class="line">import com.bean.User;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class AopTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        aopTest(&quot;aop&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void aopTest(String res) &#123;</span><br><span class="line">        ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        People p &#x3D; (People) context.getBean(&quot;people&quot;);</span><br><span class="line">        p.print(&quot;aop&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释AopLog的环绕通知的代码运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前置通知</span><br><span class="line">aop</span><br><span class="line">最终通知</span><br><span class="line">1551160014037</span><br><span class="line">1551160014060</span><br><span class="line">耗时23毫秒</span><br><span class="line">后置通知</span><br></pre></td></tr></table></figure>
<p>注释AopLog除环绕通知之外的代码运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">before</span><br><span class="line">aop</span><br><span class="line">after</span><br><span class="line">1551159843371</span><br><span class="line">1551159843396</span><br><span class="line">耗时25毫秒</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java中的“隐藏”</title>
    <url>/2020/09/22/java%E4%B8%AD%E7%9A%84%E2%80%9C%E9%9A%90%E8%97%8F%E2%80%9D/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Parent&#123;</span><br><span class="line">    public static void print()&#123;</span><br><span class="line">        System.out.print(&quot;parent&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Parent&#123;</span><br><span class="line">    public static void print()&#123;</span><br><span class="line">        System.out.print(&quot;Son&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Parent p &#x3D; new Son();</span><br><span class="line">        p.print();</span><br><span class="line">        &#x2F;&#x2F;输出parent</span><br><span class="line">        Son s &#x3D; new Son();</span><br><span class="line">        s.print();</span><br><span class="line">        &#x2F;&#x2F;输出son</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>理解继承的本质：为何与非静态方法调用的方法不一致？其实是因为设计上的原因，静态方法本身是为了不创建实例就能够直接使用的方法（例如Parent.print()），而且静态方法本质上是类方法，只属于本类，不应该被继承。于是继承的时候这个方法不能被重写（overwrite），而是被隐藏。此时应该是由句柄决定调用的是父类还是子类的方法。其实非静态方法也是如此，父类方法被重写了，最终句柄指向的方法就是被重写的方法。</p>
<p>结论：所有对象调用的方法是根据句柄来决定的，看透本质即可（了解隐藏，重写的实际运作）。</p>
<p>注：这也是静态绑定，final，static，private等方法都是这样的。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java的volatile关键字</title>
    <url>/2020/09/22/java%E7%9A%84volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>volatile保证可见行，有序性，不保证原子性。<br><br/></br><br>涉及的计算机知识：为了使得程序能够高速的运行，cpu会将内存中的值复制一份到高速缓冲区（Cache），后续直接使用Cache中的值。这种做法在单核cpu是ok，在多核cpu涉及多线程的操作时，就可能会出现数据不一致的情况。解决办法有：<br></br></br><br>（1）在总线上加LOCK#<br></br><br>（2）使用MESI缓存一致性协议<br></br></br><br>两种办法都是在硬件层面实现。早期的时候是使用第一种方法来解决，通过在总线上加锁，阻塞其他cpu对其他硬件的访问（如内存），直到当前cpu使用后释放锁，这样就保证了数据的一致性。但是这样的操作会出现同一时刻只有一个cpu访问内存，导致程序执行效率大大降低。<br></br></br><br>于是Intel推出了MESI缓存一致性协议。缓存一致性协议保证了所有cpu中的变量副本都是一致的，具体的实现是cpu写数据的时候，如果发现该变量是共享变量，会发出信号通知其他cpu将该变量置为失效，当其他cpu再次访问该变量时，发现变量失效了就会进入内存中获取最新的值。<br></br></br><br>JMM（java memory model）中规定所有的变量都是存在于主存，每个线程都有自己的工作内存（类似cpu中的Cache），线程只能操作自己的工作内存，不能访问和操作其他线程的工作内存。如果线程操作一个非共享变量，首先将变量从内存中拷贝到cpu的Cache中再进行操作。volatile实际上通过将变量标记为共享变量，被标记为共享的变量一旦被修改，就会强制更新内存，其他cpu在总线上通过嗅探这个变量的地址被改变就会将缓存该变量的缓存行设为无效，下次其他线程就会从内存中重新加载这个变量，这样就保证了数据的一致性。<br></br></br><br>先看一段代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static boolean flag &#x3D; false;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Thread t &#x3D; new Thread(() -&gt; test());</span><br><span class="line">    t.start();</span><br><span class="line">    while (!flag) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void test() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;停止100毫秒是为了保证子线程在主线程之后执行</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    flag &#x3D; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码会进入死循环，新建线程对flag的修改对主线程并不可见，对flag用volatile修饰则能够解决死循环。<br></br></br><br>volatile解决有序性：volatile会禁止指令重排序，通过类似内存屏障的方式，在变量赋值后进行load addl $0x0, (%esp)操作。指令重排序的时候不能将后面的指令重排序到内存屏障之前的位置。<br></br></br><br>拓展的相关知识：false sharing（有关MESI），synchronized，lock。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>shallow copy&amp;deep copy</title>
    <url>/2020/09/22/shallow-copy-deep-copy/</url>
    <content><![CDATA[<h4 id="拷贝前提"><a href="#拷贝前提" class="headerlink" title="拷贝前提"></a>拷贝前提</h4><p>拷贝需要实现Cloneable接口，实现clone方法，基本是调用super.clone()方法（会调用Object的clone方法，这个方法是native，由jvm进行调用）。</p>
<h4 id="shallow-copy（浅拷贝）"><a href="#shallow-copy（浅拷贝）" class="headerlink" title="shallow copy（浅拷贝）"></a>shallow copy（浅拷贝）</h4><p>直接进行拷贝对象的成员变量，对基本数据类型不影响，对对象类型有影响（直接拷贝了对象引用，拷贝后操作的成员变量是同一个对象引用，可能出现与期望不一致的情况，类似Context）。</p>
<h4 id="deep-copy（深拷贝）"><a href="#deep-copy（深拷贝）" class="headerlink" title="deep copy（深拷贝）"></a>deep copy（深拷贝）</h4><p>对对象的每一层进行对象拷贝，拷贝后操作的成员变量不是同一个对象引用。</p>
<p>（1）可以在实现clone方法的时候自行实现所有关联成员变量的拷贝，如果对象的层级很多需要实现大量的成员变量的clone方法。<br>（2）可以使用序列化和反序列化的方式进行，用到IO，可能会慢一点。需要注意的是被transient修饰的成员无法被拷贝。这种方式需要实现Serializable接口，不需要实现Cloneable接口和clone方法。</p>
<p>实现Serializable的code</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static volatile boolean flag &#x3D; false;</span><br><span class="line">    static ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException, IOException, ClassNotFoundException &#123;</span><br><span class="line">        Test a &#x3D; new Test();</span><br><span class="line">        Sub er &#x3D; new Sub();</span><br><span class="line">        er.setB(10);</span><br><span class="line">        a.setEr(er);</span><br><span class="line">&#x2F;&#x2F;        Per b &#x3D; (Per) a.clone();</span><br><span class="line">        ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);</span><br><span class="line">        oos.writeObject(a);</span><br><span class="line">        oos.flush();</span><br><span class="line">        ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));</span><br><span class="line">        Test b &#x3D; (Test) ois.readObject();</span><br><span class="line">        System.out.println(a.getSub().getB());</span><br><span class="line">        System.out.println(b.getSub().getB());</span><br><span class="line">        er.setB(1);</span><br><span class="line">        System.out.println(a.getSub().getB());</span><br><span class="line">        System.out.println(b.getSub().getB());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test implements Serializable &#123;</span><br><span class="line">    private Sub sub;</span><br><span class="line"></span><br><span class="line">    public Sub getSub() &#123;</span><br><span class="line">        return sub;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setEr(Sub sub) &#123;</span><br><span class="line">        this.sub. &#x3D; sub;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Sub implements Serializable &#123;</span><br><span class="line">    private int b;</span><br><span class="line"></span><br><span class="line">    public int getB() &#123;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setB(int b) &#123;</span><br><span class="line">        this.b &#x3D; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>static为什么不能修饰外部类</title>
    <url>/2020/09/22/static%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BF%AE%E9%A5%B0%E5%A4%96%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>static修饰的为类成员,会随着类的加载而加载,比如静态代码块,静态成员,静态方法(这里只是加载,并没有调用)等等,可以想象一下,如果把一个Class文件中的外部类设为static,目的难道是让这个类随着应用的启动而加载吗？如果在这次使用过程中根本没有使用过这个类,那么是不是就会浪费内存。这样来说设计不合理,总而言之,设计不合理的地方,Java是不会让它存在的。</p>
<p>而为什么内部类可以使用static修饰呢,因为内部类算是类的成员了,如果没有使用静态来修饰,那么在创建内部类的时候就需要先有一个外部类的对象,如果我们一直在使用内部类,那么内存中就会一直存在外部类的引用,而我们有时候只需要使用内部类,不需要外部类,那么还是会浪费内存,甚至会造成内存溢出。使用static修饰内部类之后,内部类在创建对象时就不需要有外部类对象的引用了。</p>
<p>结论:static可以用来修饰内部类,但是不可以用来修饰外部类</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>测试mysql8在innodb下不同隔离级别的锁情况</title>
    <url>/2020/09/22/%E6%B5%8B%E8%AF%95mysql8%E5%9C%A8innodb%E4%B8%8B%E4%B8%8D%E5%90%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E9%94%81%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>理解mysql在不同隔离级别下的锁情况，用到mysql8.0是因为8.0可以直接看锁的情况，8.0之前不可以。</p>
<h1 id="准备测试数据"><a href="#准备测试数据" class="headerlink" title="准备测试数据"></a>准备测试数据</h1><p>desc看表情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc student;</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| sno   | int(32)     | NO   | PRI | NULL    |       |</span><br><span class="line">| name  | varchar(32) | NO   |     | NULL    |       |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>看表中的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+-----+------+</span><br><span class="line">| sno | name |</span><br><span class="line">+-----+------+</span><br><span class="line">|   1 | 1    |</span><br><span class="line">|   2 | 2    |</span><br><span class="line">|   3 | 3    |</span><br><span class="line">+-----+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h1 id="RR隔离级别"><a href="#RR隔离级别" class="headerlink" title="RR隔离级别"></a>RR隔离级别</h1><p>在RR隔离级别下，据说mysql解决了幻读：</p>
<p>mysql客户端1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into student values(4,&#39;4&#39;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from student;</span><br><span class="line">+-----+------+</span><br><span class="line">| sno | name |</span><br><span class="line">+-----+------+</span><br><span class="line">|   1 | 1    |</span><br><span class="line">|   2 | 2    |</span><br><span class="line">|   3 | 3    |</span><br><span class="line">|   4 | 4    |</span><br><span class="line">+-----+------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>mysql客户端2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+-----+------+</span><br><span class="line">| sno | name |</span><br><span class="line">+-----+------+</span><br><span class="line">|   1 | 1    |</span><br><span class="line">|   2 | 2    |</span><br><span class="line">|   3 | 3    |</span><br><span class="line">+-----+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>mysql官方8.0的文档有说明这个问题：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html</a></p>
<ul>
<li>REPEATABLE READ</li>
</ul>
<p>This is the default isolation level for InnoDB. Consistent reads within the same transaction read the snapshot established by the first read. This means that if you issue several plain (nonlocking) SELECT statements within the same transaction, these SELECT statements are consistent also with respect to each other. See Section 15.7.2.3, “Consistent Nonlocking Reads”.</p>
<p>For locking reads (SELECT with FOR UPDATE or FOR SHARE), UPDATE, and DELETE statements, locking depends on whether the statement uses a unique index with a unique search condition, or a range-type search condition.</p>
<ul>
<li><p>For a unique index with a unique search condition, InnoDB locks only the index record found, not the gap before it.</p>
</li>
<li><p>For other search conditions, InnoDB locks the index range scanned, using gap locks or next-key locks to block insertions by other sessions into the gaps covered by the range. For information about gap locks and next-key locks, see Section 15.7.1, “InnoDB Locking”.</p>
</li>
</ul>
<p>渣翻译：</p>
<p>这是InnoDB默认的隔离级别。<font color='red'>同一事务中的一致性阅读将读取第一次建立的快照</font>，这意味着如果同时请求多个普通（非锁定）语句，则这些select语句彼此之间是保持一致的。（两个客户端开启了事务，如何事务1先读取了一次建立快照，然后客户端2修改了某些行并提交释放了事务，客户端1在事务中重新再读取将还是得到一开始的快照数据，RC级别则不是这样，后面会提到）</p>
<p>对于锁定读取（select中带有for update 或者 for share），update，delete语句，加锁取决于使用的是带有唯一搜索条件且是唯一索引还是范围类型的搜索条件。</p>
<p>提出问题：如果是带唯一条件的，可是没有索引，或者非唯一索引的话会怎样？测试一下。</p>
<h3 id="无索引情况下："><a href="#无索引情况下：" class="headerlink" title="无索引情况下："></a>无索引情况下：</h3><h5 id="mysql客户端1"><a href="#mysql客户端1" class="headerlink" title="mysql客户端1"></a>mysql客户端1</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student where name&#x3D;2 lock in share mode;</span><br><span class="line">+-----+------+</span><br><span class="line">| sno | name |</span><br><span class="line">+-----+------+</span><br><span class="line">|   2 | 2    |</span><br><span class="line">+-----+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT TRX_ID FROM INFORMATION_SCHEMA.INNODB_TRX  WHERE TRX_MYSQL_THREAD_ID &#x3D; CONNECTION_ID();</span><br><span class="line">+-----------------+</span><br><span class="line">| TRX_ID          |</span><br><span class="line">+-----------------+</span><br><span class="line">| 281479840930344 |</span><br><span class="line">+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h5 id="mysql客户端2"><a href="#mysql客户端2" class="headerlink" title="mysql客户端2"></a>mysql客户端2</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update student set name&#x3D;&#39;1&#39; where sno&#x3D;1;</span><br><span class="line">^C^C -- query aborted</span><br><span class="line">ERROR 1317 (70100): Query execution was interrupted</span><br><span class="line">mysql&gt; update student set name&#x3D;&#39;1&#39; where sno&#x3D;2;</span><br><span class="line">^C^C -- query aborted</span><br><span class="line">ERROR 1317 (70100): Query execution was interrupted</span><br><span class="line">mysql&gt; update student set name&#x3D;&#39;1&#39; where sno&#x3D;3;</span><br><span class="line">^C^C -- query aborted</span><br><span class="line">ERROR 1317 (70100): Query execution was interrupted</span><br><span class="line">mysql&gt; insert into student values(0,&#39;0&#39;);</span><br><span class="line">^C^C -- query aborted</span><br><span class="line">ERROR 1317 (70100): Query execution was interrupted</span><br><span class="line">mysql&gt; insert into student values(4,&#39;4&#39;);</span><br><span class="line">^C^C -- query aborted</span><br><span class="line">ERROR 1317 (70100): Query execution was interrupted</span><br><span class="line">mysql&gt; insert into student values(11,&#39;11&#39;);</span><br><span class="line">^C^C -- query aborted</span><br><span class="line">ERROR 1317 (70100): Query execution was interrupted</span><br></pre></td></tr></table></figure>

<h5 id="mysql客户端3"><a href="#mysql客户端3" class="headerlink" title="mysql客户端3"></a>mysql客户端3</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM performance_schema.data_locks\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 4864219688:1060:140371482961224</span><br><span class="line">ENGINE_TRANSACTION_ID: 281479840930344</span><br><span class="line">            THREAD_ID: 48</span><br><span class="line">             EVENT_ID: 103</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: NULL</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140371482961224</span><br><span class="line">            LOCK_TYPE: TABLE</span><br><span class="line">            LOCK_MODE: IS</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 4864219688:3:4:1:140371501798424</span><br><span class="line">ENGINE_TRANSACTION_ID: 281479840930344</span><br><span class="line">            THREAD_ID: 48</span><br><span class="line">             EVENT_ID: 103</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: PRIMARY</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140371501798424</span><br><span class="line">            LOCK_TYPE: RECORD</span><br><span class="line">            LOCK_MODE: S</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: supremum pseudo-record</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 4864219688:3:4:2:140371501798424</span><br><span class="line">ENGINE_TRANSACTION_ID: 281479840930344</span><br><span class="line">            THREAD_ID: 48</span><br><span class="line">             EVENT_ID: 103</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: PRIMARY</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140371501798424</span><br><span class="line">            LOCK_TYPE: RECORD</span><br><span class="line">            LOCK_MODE: S</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: 1</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 4864219688:3:4:3:140371501798424</span><br><span class="line">ENGINE_TRANSACTION_ID: 281479840930344</span><br><span class="line">            THREAD_ID: 48</span><br><span class="line">             EVENT_ID: 103</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: PRIMARY</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140371501798424</span><br><span class="line">            LOCK_TYPE: RECORD</span><br><span class="line">            LOCK_MODE: S</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: 2</span><br><span class="line">*************************** 5. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 4864219688:3:4:4:140371501798424</span><br><span class="line">ENGINE_TRANSACTION_ID: 281479840930344</span><br><span class="line">            THREAD_ID: 48</span><br><span class="line">             EVENT_ID: 103</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: PRIMARY</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140371501798424</span><br><span class="line">            LOCK_TYPE: RECORD</span><br><span class="line">            LOCK_MODE: S</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: 3</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>从8.0起支持看锁的具体信息，8.0以前不支持，甚至都不存在data_locks这个表。</p>
<p>分析一下，第一个锁的是IS锁，表级锁定，LOCK_DATA是指锁定行的主键值，如果是表锁则为null。后面锁的分别是supremum pseudo-record，1，2，3。关于supremum pseudo-record，参考 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-next-key-locks。" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-next-key-locks。</a> 意思大概是间隙锁定义supremum pseudo-record为最大的上界。这样就大概清楚了原因，使用gap lock和net key lock将所有的行都锁住了，看起来好像是锁表，但是跟锁表不是一回事（真正的锁表是lock tables table_name read或者lock tables table_name write，table_name可以有多个，同时锁定多个表)。这里show的数据是mysql客户端1加锁后就查的，如果在mysql客户端2进行更新操作和插入操作后查会有很多的记录，在commit或者rollback后（事务操作结束）这些多出来的记录会消失。</p>
<h3 id="加索引（非唯一索引）"><a href="#加索引（非唯一索引）" class="headerlink" title="加索引（非唯一索引）"></a>加索引（非唯一索引）</h3><h5 id="mysql客户端1-1"><a href="#mysql客户端1-1" class="headerlink" title="mysql客户端1"></a>mysql客户端1</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; create index name on student(name);</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; desc student;</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| sno   | int(32)     | NO   | PRI | NULL    |       |</span><br><span class="line">| name  | varchar(32) | NO   | MUL | NULL    |       |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from student where name&#x3D;2 lock in share mode;</span><br><span class="line">+-----+------+</span><br><span class="line">| sno | name |</span><br><span class="line">+-----+------+</span><br><span class="line">|   2 | 2    |</span><br><span class="line">+-----+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h5 id="mysql客户端3-1"><a href="#mysql客户端3-1" class="headerlink" title="mysql客户端3"></a>mysql客户端3</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM performance_schema.data_locks\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 4864219688:1060:140371482961224</span><br><span class="line">ENGINE_TRANSACTION_ID: 281479840930344</span><br><span class="line">            THREAD_ID: 48</span><br><span class="line">             EVENT_ID: 139</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: NULL</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140371482961224</span><br><span class="line">            LOCK_TYPE: TABLE</span><br><span class="line">            LOCK_MODE: IS</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 4864219688:3:5:1:140371501798424</span><br><span class="line">ENGINE_TRANSACTION_ID: 281479840930344</span><br><span class="line">            THREAD_ID: 48</span><br><span class="line">             EVENT_ID: 139</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: name</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140371501798424</span><br><span class="line">            LOCK_TYPE: RECORD</span><br><span class="line">            LOCK_MODE: S</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: supremum pseudo-record</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 4864219688:3:5:2:140371501798424</span><br><span class="line">ENGINE_TRANSACTION_ID: 281479840930344</span><br><span class="line">            THREAD_ID: 48</span><br><span class="line">             EVENT_ID: 139</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: name</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140371501798424</span><br><span class="line">            LOCK_TYPE: RECORD</span><br><span class="line">            LOCK_MODE: S</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: &#39;1&#39;, 1</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 4864219688:3:5:3:140371501798424</span><br><span class="line">ENGINE_TRANSACTION_ID: 281479840930344</span><br><span class="line">            THREAD_ID: 48</span><br><span class="line">             EVENT_ID: 139</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: name</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140371501798424</span><br><span class="line">            LOCK_TYPE: RECORD</span><br><span class="line">            LOCK_MODE: S</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: &#39;2&#39;, 2</span><br><span class="line">*************************** 5. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 4864219688:3:5:4:140371501798424</span><br><span class="line">ENGINE_TRANSACTION_ID: 281479840930344</span><br><span class="line">            THREAD_ID: 48</span><br><span class="line">             EVENT_ID: 139</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: name</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140371501798424</span><br><span class="line">            LOCK_TYPE: RECORD</span><br><span class="line">            LOCK_MODE: S</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: &#39;3&#39;, 3</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>发现和无索引的时候差不多。</p>
<h5 id="mysql客户端2-1"><a href="#mysql客户端2-1" class="headerlink" title="mysql客户端2"></a>mysql客户端2</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update student set name&#x3D;&#39;4&#39; where sno&#x3D;1;</span><br><span class="line">^C^C -- query aborted</span><br><span class="line">ERROR 1317 (70100): Query execution was interrupted</span><br><span class="line">mysql&gt; update student set name&#x3D;&#39;4&#39; where sno&#x3D;2;</span><br><span class="line">^C^C -- query aborted</span><br><span class="line">ERROR 1317 (70100): Query execution was interrupted</span><br><span class="line">mysql&gt; update student set name&#x3D;&#39;4&#39; where sno&#x3D;3;</span><br><span class="line">^C^C -- query aborted</span><br><span class="line">ERROR 1317 (70100): Query execution was interrupted</span><br><span class="line">mysql&gt; insert into student value(0,&#39;0&#39;);</span><br><span class="line">^C^C -- query aborted</span><br><span class="line">ERROR 1317 (70100): Query execution was interrupted</span><br><span class="line">mysql&gt; insert into student value(5,&#39;5&#39;);</span><br><span class="line">^C^C -- query aborted</span><br><span class="line">ERROR 1317 (70100): Query execution was interrupted</span><br><span class="line">mysql&gt; insert into student value(11,&#39;11&#39;);</span><br><span class="line">^C^C -- query aborted</span><br><span class="line">ERROR 1317 (70100): Query execution was interrupted</span><br></pre></td></tr></table></figure>
<p>确实修改和插入失败，类似无索引一样。</p>
<p>到此，我们需要关心的是锁的策略，本次需要关注<strong>record lock</strong>，<strong>gap lock</strong>和<strong>next key lock</strong>。</p>
<p>record lock：记录锁，锁住索引记录本身，如果没有索引就锁聚集索引，如果没有聚集索引，mysql会自动隐示的创建聚集索引。</p>
<p>gap lock：间隙锁，锁住记录之间或者第一个记录之前或者最后一个记录之后，间隙可能跨越单个索引值，多个索引值，甚至空（null）。如果是使用唯一索引来锁定唯一行来锁定的语句，不需要间隙锁定（这不包括搜索条件仅包含多列唯一索引的某些列的情况；在这种情况下，会发生间隙锁定。因为不能确定是唯一的，已测试，确实如此）。个人理解是区间的左开右开。</p>
<p>next key lock：是record lock和gap lock的组合。即左开右闭，除了最后的supremum pseudo-record是左开右开。</p>
<h1 id="RC隔离级别"><a href="#RC隔离级别" class="headerlink" title="RC隔离级别"></a>RC隔离级别</h1><p>RC隔离级别禁用了间隙锁，可能会产生幻读的问题。</p>
<h5 id="mysql客户端1-2"><a href="#mysql客户端1-2" class="headerlink" title="mysql客户端1"></a>mysql客户端1</h5><p>无索引，加共享锁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc student;</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| sno   | int(32)     | NO   | PRI | NULL    |       |</span><br><span class="line">| name  | varchar(32) | NO   |     | NULL    |       |</span><br><span class="line">| t     | varchar(32) | NO   |     | NULL    |       |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from student where name&#x3D;&#39;2&#39; for share;</span><br><span class="line">+-----+------+---+</span><br><span class="line">| sno | name | t |</span><br><span class="line">+-----+------+---+</span><br><span class="line">|   2 | 2    |   |</span><br><span class="line">+-----+------+---+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<h6 id="mysql客户端3-2"><a href="#mysql客户端3-2" class="headerlink" title="mysql客户端3"></a>mysql客户端3</h6><p>没有对间隙进行加锁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM performance_schema.data_locks\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 4864220544:1060:140371482963192</span><br><span class="line">ENGINE_TRANSACTION_ID: 281479840931200</span><br><span class="line">            THREAD_ID: 116</span><br><span class="line">             EVENT_ID: 38</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: NULL</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140371482963192</span><br><span class="line">            LOCK_TYPE: TABLE</span><br><span class="line">            LOCK_MODE: IS</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 4864220544:3:4:19:140371501803032</span><br><span class="line">ENGINE_TRANSACTION_ID: 281479840931200</span><br><span class="line">            THREAD_ID: 116</span><br><span class="line">             EVENT_ID: 38</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: PRIMARY</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140371501803032</span><br><span class="line">            LOCK_TYPE: RECORD</span><br><span class="line">            LOCK_MODE: S,REC_NOT_GAP</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: 2</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>从锁的状态看是只锁了一行的记录，尝试修改和插入操作验证一下</p>
<h5 id="mysql客户端2-2"><a href="#mysql客户端2-2" class="headerlink" title="mysql客户端2"></a>mysql客户端2</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update student set name&#x3D;&#39;10&#39; where sno&#x3D;2;</span><br><span class="line">^C^C -- query aborted</span><br><span class="line">ERROR 1317 (70100): Query execution was interrupted</span><br><span class="line">mysql&gt; update student set name&#x3D;&#39;10&#39; where sno&#x3D;1;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; update student set name&#x3D;&#39;10&#39; where sno&#x3D;3;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into student values(4,&#39;4&#39;,&#39;&#39;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>摘自官方文档</p>
<ul>
<li>READ COMMITTED</li>
</ul>
<p>Each consistent read, even within the same transaction, sets and reads its own fresh snapshot. For information about consistent reads, see Section 15.7.2.3, “Consistent Nonlocking Reads”.</p>
<p>For locking reads (SELECT with FOR UPDATE or FOR SHARE), UPDATE statements, and DELETE statements, InnoDB locks only index records, not the gaps before them, and thus permits the free insertion of new records next to locked records. Gap locking is only used for foreign-key constraint checking and duplicate-key checking.</p>
<p>Because gap locking is disabled, phantom problems may occur, as other sessions can insert new rows into the gaps. For information about phantoms, see Section 15.7.4, “Phantom Rows”.</p>
<p>Only row-based binary logging is supported with the READ COMMITTED isolation level. If you use READ COMMITTED with binlog_format=MIXED, the server automatically uses row-based logging.</p>
<p>Using READ COMMITTED has additional effects:</p>
<ul>
<li><p>For UPDATE or DELETE statements, InnoDB holds locks only for rows that it updates or deletes. Record locks for nonmatching rows are released after MySQL has evaluated the WHERE condition. This greatly reduces the probability of deadlocks, but they can still happen.</p>
</li>
<li><p>For UPDATE statements, if a row is already locked, InnoDB performs a “semi-consistent” read, returning the latest committed version to MySQL so that MySQL can determine whether the row matches the WHERE condition of the UPDATE. If the row matches (must be updated), MySQL reads the row again and this time InnoDB either locks it or waits for a lock on it.</p>
</li>
</ul>
<p>渣翻译：</p>
<p><font color='red'>即使在同一个事务中，每个一致性读取都将读取最新的快照。</font>（区别于RR级别下的读取，两个客户端进行事务操作，客户端1读取了快照，客户端2修改某些行并提交释放了锁，客户端重新读取快照会获得最新的快照数据，这里的区别似乎也正是幻读上的问题）</p>
<p>对于加锁的读（select带上for update或者for share），update和delete语句，InnoDB只会锁住索引记录，并不会在前面加上间隙锁，因此允许在锁定的记录周围插入记录。间隙锁定只用在外键约束检查和重复键检查。</p>
<p>由于禁用了间隙锁定，可能幻读的问题，因为其他会话可以插入新的记录到间隙中。</p>
<p>RC级别仅支持基于行的二进制日志。如果你使用RC级别并设置binlog_format=MIXED，服务器将会自动使用基于行的日志记录。</p>
<p>使用RC将会带来额外的影响：</p>
<ul>
<li><p>对于update或者delete语句，InnoDB只会锁住更新或者删除的行。在MySQL评估where条件后，会释放不匹配的行的record lock（这也是上面结果的原因，另外实际测试中似乎不是先锁，然后根据where条件释放不匹配的行，而是根据where条件锁住匹配的行，也可能是遍历每一条的行记录都是先加锁然后根据where条件选择是否释放锁。个人比较倾向后面的结果，在无索引的情况下，使用mysql客户端1对一行记录不通过索引列查找加X锁，mysql客户端2不通过索引进行另一行的查找加锁（X or S都行），发现客户端2在等待客户端1开启的事务的锁。）。这大大降低了死锁的可能性，但依然可以发生。</p>
</li>
<li><p>对于update语句，如果一行早已被锁住，InnoDB会执行“半一致”读取，将最新的提交版本返回给MySQL，以便MySQL能确认是否行符合where条件的update语句。如果行匹配（必须更新），MySQL会再次读取该行同时InnoDB对行进行锁定或者等待对行的锁定（应该是等待对行的锁定释放后就上锁啦）。</p>
</li>
</ul>
<p>对第一个结论，个人持不同的观点，或者说这样的写法容易让人误解，会以为是把所有记录都锁住了，然后根据where条件进行释放锁操作。个人猜测可能是遍历每一条的行记录，然后先加锁，再根据where条件选择是否释放锁（怀疑是where条件后才加锁，根本就没有释放锁的操作，test2验证）。以下测试都是在百万级的数据进行。</p>
<p>test1：在无索引的情况下，session1对一行记录不通过索引列查找加X锁，session2不通过索引进行另一行的查找加锁（X or S都行），发现session2在等待session1开启的事务的锁。而且过程中出现了一个神奇的情况，因为是根据无索引的列进行查找，则会通过cluster index（如果有主键，则cluster index是主键索引）的顺序进行查找，那么如果session1锁的行记录是比较小的记录，session2锁住的行是比较大的记录，那么session2在遍历的过程中就在等待session1锁中的记录，如果在这个过程中如果有session3通过cluster index索引到小于等于session2要锁的行的记录并加锁，这个操作会成功（在session2之后执行），session1释放锁后，session2会等待session3的锁。</p>
<p>test2：在无索引的情况下，对一条行记录进行非索引记录加锁查找，由于是百万级的数据，无索引查找非常的慢，过程中进行打印锁的信息，发现确实是进行了加锁操作，验证了是加锁然后释放锁。</p>
]]></content>
      <categories>
        <category>mysql</category>
        <category>lock</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>lock</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-371</title>
    <url>/2020/09/28/leetcode-371/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p><a href="https://leetcode.com/problems/sum-of-two-integers/" target="_blank" rel="noopener">原题链接</a></p>
<h3 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h3><p>模拟计算机的加法操作即可，先进行异或操作，再进行进位的操作。这里提一下为什么可以这样做，因为异或的本质是无进位加法，在此之上进行进位操作后就可以得到答案。</p>
<h3 id="三、code"><a href="#三、code" class="headerlink" title="三、code"></a>三、code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int getSum(int a, int b) &#123;</span><br><span class="line">    if (b &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int sum &#x3D; a ^ b;</span><br><span class="line">    &#x2F;&#x2F;进位</span><br><span class="line">    int carry &#x3D; (a &amp; b) &lt;&lt; 1;</span><br><span class="line"></span><br><span class="line">    return getSum(sum, carry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、复杂度分析"><a href="#四、复杂度分析" class="headerlink" title="四、复杂度分析"></a>四、复杂度分析</h3><p>时间复杂度：O（1），因为最差就是a和b相等，且二进制全1的情况，int最高是32，是常数级别。</p>
<p>空间复杂度：O（1），尾递归，没有栈的消耗。</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的锁</title>
    <url>/2020/10/09/Java%E4%B8%AD%E7%9A%84%E9%94%81/</url>
    <content><![CDATA[<h1 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h1><p>在了解java中的锁之前，我们需要先了解乐观锁和悲观锁。</p>
<p>悲观锁是指数据并发的时候，认为在使用数据的时候会有其他线程来修改数据，因此在获取数据的时候会进行加锁。</p>
<p>乐观锁是指数据并发的时候，乐观锁认为在使用数据的时候不会有其他线程来修改数据，因此只在更新数据的时候判断有没有其他线程更新了数据（ABA问题可以用时间戳或者版本号解决）。</p>
<p>应用场景：乐观锁适合读多写少，不加锁的特点使得性能能够大幅提升。悲观锁适合写多读少，先加锁可以保证写操作数据正确。</p>
<h1 id="java中的锁实现"><a href="#java中的锁实现" class="headerlink" title="java中的锁实现"></a>java中的锁实现</h1><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>通过无锁编程，常用的是CAS算法实现，例如并发包下的Atomic包下的类，例如AtomicInteger，通过CAS自旋实现。</p>
<p>CAS全称Campare And Swap，在不使用锁的情况下实现多线程的变量同步。CAS涉及三个操作：</p>
<p>（1）读取需要读写的内存值</p>
<p>（2）比较值</p>
<p>（3）写入新值</p>
<p>底层操作系统通过类似原语的原子操作保证比较和写入是一个原子操作，一般情况下写入是不断重试的操作。</p>
<p>举个例子：AtomicInteger的getAndIncrement方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">    int var5;</span><br><span class="line">    do &#123;</span><br><span class="line">        var5 &#x3D; this.getIntVolatile(var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;自旋直至成功</span><br><span class="line">    while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CAS存在的问题：</p>
<p>（1）CAS会引起ABA问题，JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题。</p>
<p>（2）自旋开销问题，如果长时间CAS操作不成功，会一直自旋，浪费CPU资源。</p>
<p>（3）保证一个共享变量的原子性，不能保证多个变量操作时的原子性。Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</p>
<p>关于自旋：唤醒或阻塞一个线程需要操作系统切换CPU，这种状态转换需要耗费处理器的时间，如果同步代码块中的内容非常简单，状态转换时间有可能比用户代码执行时间还要长。很多场景下，同步资源等待锁的情况很少，为了一小段时间去切换线程，非常的得不偿失。如果有多个CPU，能够让两个或以上的线程同时并行的执行，就可以让后请求的线程不阻塞不放弃CPU的执行时间，等待前面的线程是否很快就会释放锁。自旋锁有限制次数，默认是10次，可以用-XX:PreBlockSpin更改，如果达到限制次数没有成功获得锁，就需要阻塞线程（或者说挂起吧）。</p>
<p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中为默认开启，并且引入了适应性自旋锁。</p>
<p>自适应的意思是自旋的次数不再固定，由上一次在同一个锁上自旋次数及拥有者的状态来决定。如果在同一个锁对象上自旋等待成功获得过锁，并且拥有锁的线程在运行中，那么JVM认为很可能再次成功获取锁，允许将这次的自旋次数提高。如果对于某个锁，自旋很少成功，后面尝试获取这个锁的时候获取失败直接阻塞，不进行自旋操作。</p>
<p>自旋锁常见的锁形式：TicketLock、CLHlock和MCSlock。</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p>Synchronized在JDK1.6以前是悲观锁的实现，1.6引入了无锁，偏向锁，轻量级锁，重量级锁。由于无锁是CAS实现的乐观锁，1.6不能单纯的将Synchronized认为是悲观锁。</p>
<p>先探究一下Synchronized实现线程同步的原理。主要依赖两个东西，JAVA对象头和Monitor。</p>
<p>JAVA对象头在Hotspot虚拟机里包含两部分数据，Mark Word（标记字段），Klass Pointer（类型指针）。</p>
<p>Mark Word：默认存储对象的HashCode，分代年龄，锁标志位信息。存储的都是与对象自身无关的信息，运行期间Mark Word的信息会根据锁状态的不同发生改变。</p>
<p>Klass Pointer：对象指向它类元数据的指针，JVM通过它确定对象是哪个类的实例。</p>
<p>Monitor：一种同步机制，依赖底层操作系统的Mutex Lock（互斥锁）实现线程同步。每个JAVA对象都有一把Monitor锁。Monitor是线程私有的数据结构，每个线程都有Monitor Record列表，同时有全局共享的可用列表。每一个被锁的对象都会和一个Monitor关联，同时Monitor有一个Owner字段存放拥有该锁的线程的唯一标志，表示锁被该线程占用。</p>
<p>锁状态及Mark Word对于标志位</p>
<table>
<thead>
<tr>
<th align="center">锁状态</th>
<th align="center">存储内容</th>
<th align="center">标志位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">无锁</td>
<td align="center">对象HashCode，分代年龄，偏向锁标志位（0）</td>
<td align="center">01</td>
</tr>
<tr>
<td align="center">偏向锁</td>
<td align="center">偏向线程，偏向时间戳，分代年龄，偏向锁标志位（1）</td>
<td align="center">01</td>
</tr>
<tr>
<td align="center">轻量级锁</td>
<td align="center">执行栈中锁记录的指针</td>
<td align="center">00</td>
</tr>
<tr>
<td align="center">重量级锁</td>
<td align="center">指向重量级锁的指针</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">GC标志</td>
<td align="center">空，没有记录信息</td>
<td align="center">11</td>
</tr>
</tbody></table>
<p>无锁：</p>
<p>多个线程都能访问和修改同一个资源，只有一个成功，底层依赖CAS实现。</p>
<p>偏向锁：</p>
<p>一段同步代码块一直被一个线程访问，那么该线程就会自动获取锁，降低获取的代价。应用的场景是在无多线程竞争的场景下尽量减少不必要的轻量级锁执行，因为执行的过程设计多次的获取和释放CAS原子指令，偏向锁通过更新偏向线程ID的时候执行一次CAS指令即可。</p>
<p>偏向锁只有在其他线程尝试竞争偏向锁的时候释放锁，线程不会主动释放偏向锁。偏向锁释放时机在全局安全点，先暂停拥有偏向锁的线程，判断对象是否处于锁定状态。释放偏向锁后升级为轻量级锁状态。</p>
<p>1.6以后默认开启，可以用-XX:-UseBiasedLocking=false关闭。</p>
<p>轻量级锁：</p>
<p>当锁是偏向锁的时候，被另外的线程访问，偏向锁就会升级为轻量级锁。其他线程会使用自旋锁获取锁资源，提高性能。</p>
<p>代码进入同步块的时候，如果对象的锁状态为无锁状态，JVM在当前线程的栈帧中建立一个Lock Record列表，存储对象目前Mark Word的副本。</p>
<p>存储对象Mark Word副本成功后，使用CAS指针将对象的Mark Word更新为指向Lock Record的指针，将Lock Record的Owner指针指向对象的Mark Word。</p>
<p>如果更新成功，线程就拥有了锁资源。</p>
<p>如果更新失败，JVM先检查对象的Mark Word是否指向当前线程的栈帧，如果是说明当前线程已经拥有了锁资源，继续执行，否则说明处于多线程竞争中。</p>
<p>如果只有一个等待线程，线程通过自旋等待锁资源。如果自旋次数超过限制次数，或者一个线程在持有锁，一个在自旋，此时又有更多线程尝试获取锁资源，则升级为重量级锁。</p>
<p>重量级锁：</p>
<p>Mark Word中存储指向重量级锁的指针，等待的线程都会进入阻塞状态。</p>
<p>结论及注意事项：</p>
<p>（1）锁只能升级不能降级</p>
<p>（2）从上述的描述很容易看出锁是对象级别的，不是所有对象都是同一锁级别的</p>
<p>（3）偏向锁通过对比Mark Word解决锁问题，减少CAS操作</p>
<p>（4）轻量级锁通过CAS操作和自旋解决锁问题，避免线程阻塞和唤醒影响性能</p>
<p>（5）重量级锁将拥有锁以外的线程全部阻塞</p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock底层实现了公平锁和非公平锁，默认使用非公平锁。</p>
<p>公平锁是按申请锁的时间顺序获取锁，进入队列等待获取，公平锁的优点是不会造成饿死现象。缺点是吞吐效率相对非公平锁要低，等待队列中除了第一个线程外其他线程全部阻塞，CPU唤醒阻塞线程的开销比非公平锁要大。</p>
<p>非公平锁是多个线程加锁时直接获取锁，获取不到才会到等待队列中进行排队，如果此时锁刚好可用就无需阻塞直接获取到锁，所以非公平锁可能会出现后申请锁资源却先获取到锁资源的情况。非公平锁的优点是减少唤起线程的开销，整体的吞吐率更高，因为线程有几率不阻塞直接获取锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等待很久才会获得锁。</p>
<p>在源码中，公平锁比非公平锁在获取锁的时候多了一个判断，通过hasQueuedPredecessors判断当前线程是否处于队列的头部。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">    &#x2F;&#x2F; The correctness of this depends on head being initialized</span><br><span class="line">    &#x2F;&#x2F; before tail and on head.next being accurate if the current</span><br><span class="line">    &#x2F;&#x2F; thread is first in queue.</span><br><span class="line">    Node t &#x3D; tail; &#x2F;&#x2F; Read fields in reverse initialization order</span><br><span class="line">    Node h &#x3D; head;</span><br><span class="line">    Node s;</span><br><span class="line">    return h !&#x3D; t &amp;&amp;</span><br><span class="line">        ((s &#x3D; h.next) &#x3D;&#x3D; null || s.thread !&#x3D; Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下：公平锁是排队，非公平锁是插队。</p>
<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>可重入锁又名递归锁，指同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提是同一个对象或者class），不会因为之前获取过还没释放而阻塞。Synchronized和ReentrantLock都是可冲入锁，可重入锁可以一定程度上避免死锁。</p>
<h3 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h3><p>共享锁是指锁可以被多个线程持有，如果线程A对数据Data加了共享锁后，其他线程也只能对Data加共享锁，不能加排他锁。获取共享锁的线程只能读，不能修改Data。</p>
<p>排他锁是指锁只能被一个线程持有，如果给一个数据加上排他锁，其他线程不能对数据再加上任何类型的锁。获得排他锁的线程既可以读也可以写。Synchronized和ReentrantLock都是排他锁。</p>
<p>ReentrantReadWriteLock实现了共享锁和排他锁，内部有两把锁，ReadLock和WriteLock。ReadLock就是读锁，是共享锁的实现，WriteLock是写锁，是排他锁的实现。</p>
<p>在AQS中有个int变量state，表示多少线程获取了锁。在排他锁的情况下，这个变量是0或者1（如果是可重入锁state表示重入的次数），共享锁中就是持有锁的数量。在ReentrantReadWriteLock的实现中，直接将state变量对半切分了，高16位用于统计读锁个数，低16位用于统计写锁个数。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所有的锁最终都是用到了CAS进行数据保证，甚至利用CAS避免线程阻塞使得从用户态切换到内核态，但是为了尽可能的减少CAS操作（因为涉及到缓存失效，其他线程需要从主存中重新获取，开销挺大），做了其他的一些优化。Synchronized和ReentrantLock效率上在JDK1.6版本以后几乎没有性能的差距，在并发量不高的情况下Synchronized也许效率会更高。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>lock</category>
      </categories>
      <tags>
        <tag>lock</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型（JMM）</title>
    <url>/2020/10/14/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88JMM%EF%BC%89/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Java Memory Model，简称JMM，翻译为Java内存模型。具体是指Java中线程的工作方式。</p>
<p>前置知识：线程有自己的工作内存，各个线程之间是不共享自己工作内存数据的，线程之间也是不能直接进行通信。</p>
<p>并发情况下，多个线程可能同时读取了同个变量（拷贝了副本），当这些线程同时进行修改的时候，其他工作线程对变量不可见，这就会导致出现并发修改同个变量错误的问题。为了解决这个问题，提出了Java内存模型。</p>
<h3 id="工作流程图"><a href="#工作流程图" class="headerlink" title="工作流程图"></a>工作流程图</h3><p><img src="https://cdn.jsdelivr.net/gh/fuxyzz/cdn/images/jmm.png" alt="avatar"></p>
<p>如图所示，多线程并发共享变量的时候，用一系列的原子操作来进行。</p>
<h3 id="JMM中的数据原子操作"><a href="#JMM中的数据原子操作" class="headerlink" title="JMM中的数据原子操作"></a>JMM中的数据原子操作</h3><p>read：从主内存中读取数据</p>
<p>load：将read读取到的数据写入线程的工作内存中</p>
<p>use：从工作内存中读取数据进行计算</p>
<p>assign：将计算好的值重新写入工作内存中</p>
<p>store：将工作内存中的数据写入主内存</p>
<p>write：将store写入的值赋值给主内存中的变量</p>
<p>lock：将主内存变量加锁，标志为独占状态</p>
<p>unlock：将主内存变量解锁，标志为其他线程可以锁定该变量</p>
<p>lock和unlock是早期解决不同线程之间变量同步的方案，通过加锁的方式将并发操作变为串行化操作来实现。在当今服务器CPU核心很多的情况下，这种操作会大大降低效率。后续的方案是MESI缓存一致性协议，CPU通过总线嗅探机制感知数据的变化从而将自己的缓存数据失效来实现，同时为了解决多个线程同时并发修改的问题，锁定变量操作改为在store的时候进行加锁，降低锁的力度，更高效。</p>
<p>Java中是通过volatile关键字修饰变量来达到的。注意volatile不能保证原子性，假设有两个线程获取了变量i，都进行i++ 操作，线程1与线程2都执行到assign，然后线程1先执行store，此时由于总线嗅探机制，线程2会重新从主存中获取i的值，然后执行store和write，相当于没有进行i++ 操作，这也是因为i++并不是一个原子操作的原因。</p>
<h3 id="高并发三大特性"><a href="#高并发三大特性" class="headerlink" title="高并发三大特性"></a>高并发三大特性</h3><p>高并发三大特性：原子性，有序性，一致性（可见性）。</p>
<p>volatile保证了有序性和一致性，有序性是通过禁止指令重排序实现，一致性通过底层的MESI缓存一致性协议实现。</p>
<p>Synchronized保证了原子性，有序性和一致性。原子性通过monitorenter和monitorexit实现，底层是调用了JMM中原子操作lock和unlock，可以理解是由于锁将代码串行化执行保证了原子性。一致性是通过在unlock之前必须先将变量同步回主存（即执行store和write）。有序性与原子性一样也是通过串行化执行来实现。</p>
<h3 id="happends-before（先行发生）原则"><a href="#happends-before（先行发生）原则" class="headerlink" title="happends-before（先行发生）原则"></a>happends-before（先行发生）原则</h3><p>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</p>
<p>锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作</p>
<p>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</p>
<p>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</p>
<p>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</p>
<p>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</p>
<p>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</p>
<p>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</p>
<p>这8条规则适用单线程，jvm会将没有数据依赖的语句进行指令重排序，多线程可能会出现问题。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java双亲委派模型</title>
    <url>/2020/10/15/Java%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>双亲委派模型是指当类加载器收到类加载任务时，会先交由自己的父类加载器去尝试加载，最终会传递到BootstrapClassLoader，只有当父类加载器无法加载任务时才会尝试自己加载。</p>
<h3 id="常见类加载器"><a href="#常见类加载器" class="headerlink" title="常见类加载器"></a>常见类加载器</h3><p>BootstrapClassLoader（启动类加载器）：负责核心类库的加载，rt.jar，java.lang.*，JVM_HOME/lib目录下的，构造ExtClassLoader和AppClassLoader。</p>
<p>ExtClassLoader（拓展类加载器）：负责加载jre/lib/ext的jar。</p>
<p>AppClassLoader（系统类加载器）：加载应用程序的主函数类。</p>
<h3 id="双亲委派模型的打破"><a href="#双亲委派模型的打破" class="headerlink" title="双亲委派模型的打破"></a>双亲委派模型的打破</h3><p>Java SPI机制：SPI全称Service Provider Interface，用于接入产商自定义组件，例如JDBC。SPI的思想是系统抽象的各个模块有多种实现方案，例如JDBC，日志模块等。面向对象中，我们倾向于基于接口编程，模块直接不对实现类进行硬编码，否则会破坏开闭原则。为了能在模块装配的时候不需要在程序中显示声明，需要服务发现机制，SPI就是提供这样一个服务。</p>
<p>SPI的约定：当服务提供者提供服务接口后，在jar包下的META-INF/services/目录同时创建一个以服务接口命名的具体实现类文件。当外部程序装配模块的时候，能够以META-INF/services/里的配置文件找到具体的实现类并实例化。jdk中提供了java.util.ServiceLoader进行实现。</p>
<p>以JDBC为例，我们通常用以下方式获取数据库连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;testdb&quot;;    </span><br><span class="line">Connection conn &#x3D; java.sql.DriverManager.getConnection(url, &quot;name&quot;, &quot;password&quot;);</span><br></pre></td></tr></table></figure>

<p>getConnection()继续调用了重载的getConnection方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Connection getConnection(String url,</span><br><span class="line">    java.util.Properties info) throws SQLException &#123;</span><br><span class="line"></span><br><span class="line">    return (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重载的方法，省略若干代码，看注释可以知道此时得到的callerCL为null，那么就会执行Thread.currentThread().getContextClassLoader()并赋值给callerCL，而且后面调用isDriverAllowed(aDriver.driver, callerCL)就是使用此时获取的类加载器进行类的加载。于是重点就是停留在Thread.currentThread().getContextClassLoader()。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static Connection getConnection(</span><br><span class="line">    String url, java.util.Properties info, Class&lt;?&gt; caller) throws SQLException &#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * When callerCl is null, we should check the application&#39;s</span><br><span class="line">     * (which is invoking this class indirectly)</span><br><span class="line">     * classloader, so that the JDBC driver class outside rt.jar</span><br><span class="line">     * can be loaded from here.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    ClassLoader callerCL &#x3D; caller !&#x3D; null ? caller.getClassLoader() : null;</span><br><span class="line">    synchronized(DriverManager.class) &#123;</span><br><span class="line">        &#x2F;&#x2F; synchronize loading of the correct classloader.</span><br><span class="line">        if (callerCL &#x3D;&#x3D; null) &#123;</span><br><span class="line">            callerCL &#x3D; Thread.currentThread().getContextClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    for(DriverInfo aDriver : registeredDrivers) &#123;</span><br><span class="line">        &#x2F;&#x2F; If the caller does not have permission to load the driver then</span><br><span class="line">        &#x2F;&#x2F; skip it.</span><br><span class="line">        if(isDriverAllowed(aDriver.driver, callerCL)) &#123;</span><br><span class="line">            ...</span><br><span class="line">            ...</span><br><span class="line">            ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ...</span><br><span class="line">            ...</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static boolean isDriverAllowed(Driver driver, ClassLoader classLoader) &#123;</span><br><span class="line">    boolean result &#x3D; false;</span><br><span class="line">    if(driver !&#x3D; null) &#123;</span><br><span class="line">        Class&lt;?&gt; aClass &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            aClass &#x3D;  Class.forName(driver.getClass().getName(), true, classLoader);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            result &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         result &#x3D; ( aClass &#x3D;&#x3D; driver.getClass() ) ? true : false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ClassLoader getContextClassLoader() &#123;</span><br><span class="line">    if (contextClassLoader &#x3D;&#x3D; null)</span><br><span class="line">        return null;</span><br><span class="line">    SecurityManager sm &#x3D; System.getSecurityManager();</span><br><span class="line">    if (sm !&#x3D; null) &#123;</span><br><span class="line">        ClassLoader.checkClassLoaderPermission(contextClassLoader,</span><br><span class="line">                                               Reflection.getCallerClass());</span><br><span class="line">    &#125;</span><br><span class="line">    return contextClassLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下getContextClassLoader方法，发现仅仅只是简单的校验就获取了。我们回到一开始的java.sql.DriverManager.getConnection(url, “name”, “password”)，这里的DriverManager，我们看一下它的初始化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private DriverManager()&#123;&#125;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">    loadInitialDrivers();</span><br><span class="line">    println(&quot;JDBC DriverManager initialized&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void loadInitialDrivers() &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    for (String aDriver : driversList) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            println(&quot;DriverManager.Initialize: loading &quot; + aDriver);</span><br><span class="line">            Class.forName(aDriver, true,</span><br><span class="line">                    ClassLoader.getSystemClassLoader());</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            println(&quot;DriverManager.Initialize: load failed: &quot; + ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ClassLoader getSystemClassLoader() &#123;</span><br><span class="line">    initSystemClassLoader();</span><br><span class="line">    if (scl &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    SecurityManager sm &#x3D; System.getSecurityManager();</span><br><span class="line">    if (sm !&#x3D; null) &#123;</span><br><span class="line">        checkClassLoaderPermission(scl, Reflection.getCallerClass());</span><br><span class="line">    &#125;</span><br><span class="line">    return scl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造方法被private修饰阻止了实例化，那么看一下静态代码块的loadInitialDrivers方法，省略若干代码，我们看一下ClassLoader.getSystemClassLoader()，发现了initSystemClassLoader()，继续往下看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static synchronized void initSystemClassLoader() &#123;</span><br><span class="line">    if (!sclSet) &#123;</span><br><span class="line">        if (scl !&#x3D; null)</span><br><span class="line">            throw new IllegalStateException(&quot;recursive invocation&quot;);</span><br><span class="line">        sun.misc.Launcher l &#x3D; sun.misc.Launcher.getLauncher();</span><br><span class="line">        if (l !&#x3D; null) &#123;</span><br><span class="line">            Throwable oops &#x3D; null;</span><br><span class="line">            scl &#x3D; l.getClassLoader();</span><br><span class="line">            try &#123;</span><br><span class="line">                scl &#x3D; AccessController.doPrivileged(</span><br><span class="line">                    new SystemClassLoaderAction(scl));</span><br><span class="line">            &#125; catch (PrivilegedActionException pae) &#123;</span><br><span class="line">                oops &#x3D; pae.getCause();</span><br><span class="line">                if (oops instanceof InvocationTargetException) &#123;</span><br><span class="line">                    oops &#x3D; oops.getCause();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (oops !&#x3D; null) &#123;</span><br><span class="line">                if (oops instanceof Error) &#123;</span><br><span class="line">                    throw (Error) oops;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; wrap the exception</span><br><span class="line">                    throw new Error(oops);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sclSet &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Launcher() &#123;</span><br><span class="line">    Launcher.ExtClassLoader var1;</span><br><span class="line">    try &#123;</span><br><span class="line">        var1 &#x3D; Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">    &#125; catch (IOException var10) &#123;</span><br><span class="line">        throw new InternalError(&quot;Could not create extension class loader&quot;, var10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        this.loader &#x3D; Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">    &#125; catch (IOException var9) &#123;</span><br><span class="line">        throw new InternalError(&quot;Could not create application class loader&quot;, var9);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.currentThread().setContextClassLoader(this.loader);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里就是实现的关键，注意initSystemClassLoader的以下代码段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sun.misc.Launcher l &#x3D; sun.misc.Launcher.getLauncher();</span><br><span class="line"></span><br><span class="line">scl &#x3D; l.getClassLoader();</span><br><span class="line">try &#123;</span><br><span class="line">    scl &#x3D; AccessController.doPrivileged(</span><br><span class="line">        new SystemClassLoaderAction(scl));</span><br><span class="line">&#125; catch (PrivilegedActionException pae) &#123;</span><br><span class="line">    oops &#x3D; pae.getCause();</span><br><span class="line">    if (oops instanceof InvocationTargetException) &#123;</span><br><span class="line">        oops &#x3D; oops.getCause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下getLauncher()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Launcher() &#123;</span><br><span class="line">    Launcher.ExtClassLoader var1;</span><br><span class="line">    try &#123;</span><br><span class="line">        var1 &#x3D; Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">    &#125; catch (IOException var10) &#123;</span><br><span class="line">        throw new InternalError(&quot;Could not create extension class loader&quot;, var10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        this.loader &#x3D; Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">    &#125; catch (IOException var9) &#123;</span><br><span class="line">        throw new InternalError(&quot;Could not create application class loader&quot;, var9);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.currentThread().setContextClassLoader(this.loader);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现这里先获取了当前的系统加载器，然后将系统加载器，然后将系统加载器作为线程上下文加载器的父类，相当于构造链表一样。我们再看一下new SystemClassLoaderAction(scl)，发现这个类居然有个run方法，而且是使用java.system.class.loader作为实现的线程上下文加载器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SystemClassLoaderAction(ClassLoader parent) &#123;</span><br><span class="line">    this.parent &#x3D; parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ClassLoader run() throws Exception &#123;</span><br><span class="line">    String cls &#x3D; System.getProperty(&quot;java.system.class.loader&quot;);</span><br><span class="line">    if (cls &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Constructor&lt;?&gt; ctor &#x3D; Class.forName(cls, true, parent)</span><br><span class="line">        .getDeclaredConstructor(new Class&lt;?&gt;[] &#123; ClassLoader.class &#125;);</span><br><span class="line">    ClassLoader sys &#x3D; (ClassLoader) ctor.newInstance(</span><br><span class="line">        new Object[] &#123; parent &#125;);</span><br><span class="line">    Thread.currentThread().setContextClassLoader(sys);</span><br><span class="line">    return sys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里我们可以得出结论：对于SPI，通过配置文件java.system.class.loader的方式实现了额外的线程上下文加载器并用于加载SPI组件，于是就打破了双亲委派模型。其实我们平时实现自定义类加载器的方式也是打破双亲委派模型，我们通过重写findClass（1.2之前是通过重写loadClass）阻止使用双亲委派模型。</p>
<p>ps：为什么要使用自定义类加载器？因为系统类加载器只会加载指定目录下的class文件，想加载自己的文件就可以通过自定义ClassLoader，可以用于文件改动后不想重启Java程序的热加载。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的retry</title>
    <url>/2020/10/19/Java%E4%B8%AD%E7%9A%84retry/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>最近在看线程池源码的时候看到有关阻塞队列源码中使用了 <em>retry</em> ，有点懵逼，查阅资料总结一下。</p>
<p><em>retry</em> 是作用于循环中，用于提前中断循环，可以搭配 <em>continue</em> 和 <em>break</em> 使用。使用时在循环之前声明 <em>retry:</em> ，在需要中断的地方使用 <em>break retry</em> 或者 <em>continue retry</em>。看起来很像goto。</p>
<p>搭配continue：中断整个嵌套循环循环，从 <em>retry:</em> 标记的循环继续执行，注意这里可能有坑，你标记写在第几层循环，就是从哪里开始。</p>
<p>搭配break：中断标记开始的循环，注意标记外层的循环继续执行。</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;retry写最外层循环</span><br><span class="line">    public static void testBreak() &#123;</span><br><span class="line">        retry:</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; 3; j++) &#123;</span><br><span class="line">                for (int k &#x3D; 0; k &lt; 3; k++) &#123;</span><br><span class="line">                    System.out.println(i + &quot; &quot; + j + &quot; &quot; + k);</span><br><span class="line">                    if (k &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                        break retry;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">    输出：</span><br><span class="line">    0 0 0</span><br><span class="line">    0 0 1</span><br><span class="line">    *&#x2F;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;retry写第二层循环</span><br><span class="line">    public static void testBreak2() &#123;</span><br><span class="line">&#x2F;&#x2F;        retry:</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">            retry:</span><br><span class="line">            for (int j &#x3D; 0; j &lt; 3; j++) &#123;</span><br><span class="line">                for (int k &#x3D; 0; k &lt; 3; k++) &#123;</span><br><span class="line">                    System.out.println(i + &quot; &quot; + j + &quot; &quot; + k);</span><br><span class="line">                    if (k &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                        break retry;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*</span><br><span class="line">    输出：</span><br><span class="line">    0 0 0</span><br><span class="line">    0 0 1</span><br><span class="line">    1 0 0</span><br><span class="line">    1 0 1</span><br><span class="line">    2 0 0</span><br><span class="line">    2 0 1</span><br><span class="line">    *&#x2F;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;retry写最外层循环</span><br><span class="line">    public static void testContinue1() &#123;</span><br><span class="line">        retry:</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; 5; j++) &#123;</span><br><span class="line">                for (int k &#x3D; 0; k &lt; 5; k++) &#123;</span><br><span class="line">                    System.out.println(i + &quot; &quot; + j + &quot; &quot; + k);</span><br><span class="line">                    if (k &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                        continue retry;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*</span><br><span class="line">    输出：</span><br><span class="line">    0 0 0</span><br><span class="line">    0 0 1</span><br><span class="line">    1 0 0</span><br><span class="line">    1 0 1</span><br><span class="line">    2 0 0</span><br><span class="line">    2 0 1</span><br><span class="line">    *&#x2F;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;retry写第二层循环</span><br><span class="line">    public static void testContinue2() &#123;</span><br><span class="line">&#x2F;&#x2F;        retry:</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">            retry:</span><br><span class="line">            for (int j &#x3D; 0; j &lt; 3; j++) &#123;</span><br><span class="line">                for (int k &#x3D; 0; k &lt; 3; k++) &#123;</span><br><span class="line">                    System.out.println(i + &quot; &quot; + j + &quot; &quot; + k);</span><br><span class="line">                    if (k &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                        continue retry;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*</span><br><span class="line">    输出：</span><br><span class="line">    0 0 0</span><br><span class="line">    0 0 1</span><br><span class="line">    0 1 0</span><br><span class="line">    0 1 1</span><br><span class="line">    0 2 0</span><br><span class="line">    0 2 1</span><br><span class="line">    1 0 0</span><br><span class="line">    1 0 1</span><br><span class="line">    1 1 0</span><br><span class="line">    1 1 1</span><br><span class="line">    1 2 0</span><br><span class="line">    1 2 1</span><br><span class="line">    2 0 0</span><br><span class="line">    2 0 1</span><br><span class="line">    2 1 0</span><br><span class="line">    2 1 1</span><br><span class="line">    2 2 0</span><br><span class="line">    2 2 1</span><br><span class="line">    *&#x2F;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-102</title>
    <url>/2020/10/21/leetcode-102/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">原题链接</a></p>
<p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>

<p>&nbsp;</p>

<p><strong>示例：</strong><br>
二叉树：<code>[3,9,20,null,null,15,7]</code>,</p>

<pre>    3
   / \
  9  20
    /  \
   15   7
</pre>

<p>返回其层次遍历结果：</p>

<pre>[
  [3],
  [9,20],
  [15,7]
]
</pre>

<h3 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h3><p>利用队列进行广搜即可。先压入根节点，当队列不为空一直循环，循环中嵌套一个子循环，先获取队列的长度，然后子循环执行队列长度的次数，每次执行取出队头元素，将队头的左右结点压入队尾（如果有的话）。执行完子循环就是遍历完当前层数的结点，可以加入结果。</p>
<h3 id="三、code"><a href="#三、code" class="headerlink" title="三、code"></a>三、code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; q &#x3D; new ArrayDeque&lt;&gt;();</span><br><span class="line">    q.addLast(root);</span><br><span class="line">    while (!q.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; subAns &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i &#x3D; 0, len &#x3D; q.size(); i &lt; len; i++) &#123;</span><br><span class="line">            TreeNode node &#x3D; q.removeFirst();</span><br><span class="line">            subAns.add(node.val);</span><br><span class="line">            if (node.left !&#x3D; null) &#123;</span><br><span class="line">                q.addLast(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.right !&#x3D; null) &#123;</span><br><span class="line">                q.addLast(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans.add(subAns);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、复杂度分析"><a href="#四、复杂度分析" class="headerlink" title="四、复杂度分析"></a>四、复杂度分析</h3><p>时间复杂度：O（n），入队n个结点，出队n个结点。</p>
<p>空间复杂度：O（1），除去返回的答案，没有额外的开销。</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-75</title>
    <url>/2020/10/21/leetcode-75/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p><a href="https://leetcode.com/problems/sort-colors/" target="_blank" rel="noopener">原题链接</a></p>
<p>给定一个包含红色、白色和蓝色，一共&nbsp;<em>n </em>个元素的数组，<strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank">原地</a></strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>

<p>此题中，我们使用整数 0、&nbsp;1 和 2 分别表示红色、白色和蓝色。</p>

<p><strong>注意:</strong><br>
不能使用代码库中的排序函数来解决这道题。</p>

<p><strong>示例:</strong></p>

<pre><strong>输入:</strong> [2,0,2,1,1,0]
<strong>输出:</strong> [0,0,1,1,2,2]</pre>

<p><strong>进阶：</strong></p>

<ul>
    <li>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>
    首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</li>
    <li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li>
</ul>

<h3 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h3><p>双指针，指针1指向头，负责交换0，指针2指向尾，负责交换2。</p>
<h3 id="三、code"><a href="#三、code" class="headerlink" title="三、code"></a>三、code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void sortColors(int[] nums) &#123;</span><br><span class="line">    int p1 &#x3D; 0, p2 &#x3D; nums.length - 1;</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; p2; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F;可能换了个2回来</span><br><span class="line">        while (i &lt; p2 &amp;&amp; nums[i] &#x3D;&#x3D; 2) &#123;</span><br><span class="line">            swap(nums, i, p2--);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;换了个0回来继续再换，下次再做就漏了</span><br><span class="line">        if (nums[i] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            swap(nums, i, p1++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void swap(int[] arr, int a, int b) &#123;</span><br><span class="line">    int temp &#x3D; arr[a];</span><br><span class="line">    arr[a] &#x3D; arr[b];</span><br><span class="line">    arr[b] &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、复杂度分析"><a href="#四、复杂度分析" class="headerlink" title="四、复杂度分析"></a>四、复杂度分析</h3><p>时间复杂度：O（n），遍历一次。</p>
<p>空间复杂度：O（1），原地交换，没有额外开销。</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池</title>
    <url>/2020/10/26/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>前置知识：</p>
<p>线程是调度CPU的最小单位，也叫轻量级进程LWP（light weight process）。</p>
<p>内核级线程（kernel level threads，简称KLT）</p>
<ul>
<li>线程管理的所有工作（创建和撤销）由操作系统完成</li>
<li>操作系统内核提供应用程序API，供开发者使用KLT</li>
</ul>
<p>用户级线程（user level threads，简称ULT）</p>
<ul>
<li>用户空间运行线程库，任何应用程序都可以通过使用线程库被设计成多线程程序。线程库是用于用户级线程管理的一个例程包，提供多线程应用程序的开发和运行支撑环境。包含：用于创建和销毁线程的代码、在线程间传递数据和消息的代码、调度线程执行的代码以及保存和恢复线程上下文的代码。</li>
<li>线程切换不需要内核模式</li>
<li>允许自己实现调度线程的算法</li>
<li>不需要内核支持，可以跨OS</li>
<li>不能利用多核处理器，每个进程只有一个ULT能运行</li>
<li>一个ULT阻塞会导致整个进程阻塞</li>
</ul>
<p>Java线程依赖于系统内核（KLT），通过JVM调用系统库创建内核线程。因为创建和销毁都会依赖内核，频繁创建和销毁的代价特别大，所以需要池化技术来达到复用线程的降低开销。线程池就是一个线程缓存，负责对线程进行统一分配、调优和监控。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>复用线程，减少线程创建和销毁的开销，提高性能</li>
<li>提高响应速度，任务到来时不需要等到线程创建就能立刻执行</li>
<li>提高线程可管理性，统一分配、调优与监控</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>单个任务处理时间短</li>
<li>需要处理的任务数量大</li>
</ul>
<p>需要同时满足以上两个条件的大部分程序都可以用线程池。</p>
<h2 id="Java中的实现"><a href="#Java中的实现" class="headerlink" title="Java中的实现"></a>Java中的实现</h2><h4 id="线程池的五种状态"><a href="#线程池的五种状态" class="headerlink" title="线程池的五种状态"></a>线程池的五种状态</h4><p>running（运行中）：能接受新任务和处理已添加的任务</p>
<p>shutdown（关闭）：不接受新任务，能处理已添加的任务</p>
<p>stop（停止）：不接受新任务，不处理已添加的任务，并中断正在执行的任务</p>
<p>tidying（整理）：所有任务已终止，ctl记录的任务数量为0，ctl负责记录线程池的运行状态与活动线程数量</p>
<p>terminated（终止）：线程池终止</p>
<p>关于状态和数量的实现，以ThreadPoolExecutor中的代码为例，代码中使用了的位运算，代码增加了注释方便理解。线程池中只使用了ctl一个变量来表示状态和工作线程数量，更新的时候用cas即可。如果使用多个变量，在并发的情况下需要加锁等操作，这是个很取巧的优化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;原子类，实现并发情况下的操作，初始化为running状态，且线程数为0</span><br><span class="line">private final AtomicInteger ctl &#x3D; new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;32 - 3 &#x3D; 29，高3位存储状态，低29位存储线程数量</span><br><span class="line">private static final int COUNT_BITS &#x3D; Integer.SIZE - 3;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;线程数量计算的掩码，类似计算机网络的子网掩码的计算方法，得到0001 1111 1111 1111 1111 1111 1111 1111</span><br><span class="line">private static final int COUNT_MASK &#x3D; (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; runState is stored in the high-order bits</span><br><span class="line">&#x2F;*</span><br><span class="line">* -1的补码是1111 1111 1111 1111 1111 1111 1111 1111</span><br><span class="line">* 左移29位得到1110 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">*&#x2F;</span><br><span class="line">private static final int RUNNING    &#x3D; -1 &lt;&lt; COUNT_BITS;</span><br><span class="line">&#x2F;&#x2F;同上，得到0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">private static final int SHUTDOWN   &#x3D;  0 &lt;&lt; COUNT_BITS;</span><br><span class="line">&#x2F;&#x2F;同上，得到0010 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">private static final int STOP       &#x3D;  1 &lt;&lt; COUNT_BITS;</span><br><span class="line">&#x2F;&#x2F;同上，得到0100 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">private static final int TIDYING    &#x3D;  2 &lt;&lt; COUNT_BITS;</span><br><span class="line">&#x2F;&#x2F;同上，得到0110 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">private static final int TERMINATED &#x3D;  3 &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Packing and unpacking ctl</span><br><span class="line">&#x2F;&#x2F;根据ctl的值计算出状态</span><br><span class="line">private static int runStateOf(int c)     &#123; return c &amp; ~COUNT_MASK; &#125;</span><br><span class="line">&#x2F;&#x2F;根据ctl的值计算出线程数量</span><br><span class="line">private static int workerCountOf(int c)  &#123; return c &amp; COUNT_MASK; &#125;</span><br><span class="line">&#x2F;&#x2F;根据run state和worker count计算出ctl需要更新的值</span><br><span class="line">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="基本参数"><a href="#基本参数" class="headerlink" title="基本参数"></a>基本参数</h4><p>从ThreadPoolExecutor的构造方法看起</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler) &#123;</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;&#x3D; 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (workQueue &#x3D;&#x3D; null || threadFactory &#x3D;&#x3D; null || handler &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.corePoolSize &#x3D; corePoolSize;</span><br><span class="line">    this.maximumPoolSize &#x3D; maximumPoolSize;</span><br><span class="line">    this.workQueue &#x3D; workQueue;</span><br><span class="line">    this.keepAliveTime &#x3D; unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory &#x3D; threadFactory;</span><br><span class="line">    this.handler &#x3D; handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>corePoolSize：核心线程数，正常情况下能够一直呆在线程池中的线程数（只要线程池是running状态，且线程不挂掉）。</p>
<p>maximumPoolSize：最多存在的工作线程数，当workQueue满了，且工作线程数大于corePoolSize也小于maximumPoolSize，则开启临时线程，相当于聘用临时工。</p>
<p>keepAliveTime &amp; unit：时间的大小和时间的单位，临时线程空闲时间超过这个时间就kill掉，相当于解聘临时工。</p>
<p>workQueue：阻塞队列，在任意时刻，永远只有一个线程能够进行入队或者出队，是线程安全的队列。新请求来临，如果工作线程都在工作且队列未满，就将新的任务加入阻塞队列。</p>
<p>threadFactory：创建线程的工厂类。</p>
<p>handler：负责拒绝任务时的操作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fuxyzz/cdn/images/thread_pool.png" alt="线程池工作流程图"></p>
<p>如图所示，按序号顺序执行。</p>
<p>（1）如果工作线程数小于corePoolSize，创建新的线程</p>
<p>（2）如果工作线程数大于等于corePoolSize，队列未满，加入等待队列，队列满了，如果工作线程大于等于maximumPoolSize，拒绝任务，否则创建临时线程处理任务</p>
<p>（3）拒绝通常有3种情况：</p>
<ul>
<li><p>添加任务时处于running且队列满了且工作线程大于等于maximumPoolSize</p>
</li>
<li><p>添加任务时处于shutdown</p>
</li>
<li><p>处于stop状态，stop会中断当前的任务并拒绝，并拒绝后续的任务</p>
</li>
</ul>
<p>（4）拒绝任务会执行拒绝策略，拒绝策略通常有4种：</p>
<ul>
<li><p>AbortPolicy，默认的拒绝策略，直接抛出异常。</p>
</li>
<li><p>CallerRunsPolicy，拒绝后将任务交由调用execute方法的线程执行（主线程，可能有阻塞的风险）。如果线程池处于shutdown或以上（stop，terminated），会直接丢弃任务。</p>
</li>
<li><p>DiscardOldestPolicy，抛弃最久未执行的任务然后重试（调用execute重试）,最久就是排队最久的，就是队头的任务。而且队列嘛，只能先进先出，那就只能抛弃队头的任务了。如果线程池处于shutdown或以上（stop，terminated），会直接丢弃任务。</p>
</li>
<li><p>DiscardPolicy，直接抛弃被拒绝的任务。</p>
</li>
</ul>
<h4 id="执行与复用"><a href="#执行与复用" class="headerlink" title="执行与复用"></a>执行与复用</h4><p>先明确一个概念，线程是底层操作系统实现的，JAVA中是JVM通过调用操作系统提供的api去原生的执行。</p>
<p>从ThreadPoolExecutor的execute看起</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">     &#x2F;*</span><br><span class="line">     * 执行分3步：</span><br><span class="line">     * 1.如果少于corePoolSize且线程池处于运行态则开启新的线程去执行传入的任务。</span><br><span class="line">     * </span><br><span class="line">     * 2.如果不是1情况，则尝试将任务塞入阻塞队列，如果能塞入，进行 double-check，double-check主要是为了看是不是有工作线程中是否有线程挂了，还有看一下运行状态，如果是shundown要把任务拒绝。</span><br><span class="line">     *</span><br><span class="line">     * 3.如果不能塞入阻塞队列，尝试添加一个临时的线程去执行，如果失败，说明线程已经超过maximumPoolSize，或者是shutdown状态，要拒绝任务。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int c &#x3D; ctl.get();</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        if (addWorker(command, true))</span><br><span class="line">            return;</span><br><span class="line">        c &#x3D; ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        int recheck &#x3D; ctl.get();</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        else if (workerCountOf(recheck) &#x3D;&#x3D; 0)</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (!addWorker(command, false))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>execute方式主要是线程的工作方式。workQueue的实现较为简单，以ArrayBlockingQueue为例，使用ReentrantLock辅助同一时间只能入队或者是出队。重点关注一下addWorker方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">    &#x2F;&#x2F;这里主要是检查</span><br><span class="line">    retry:</span><br><span class="line">    for (int c &#x3D; ctl.get();;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 检查线程池状态，检查队列</span><br><span class="line">        if (runStateAtLeast(c, SHUTDOWN)</span><br><span class="line">            &amp;&amp; (runStateAtLeast(c, STOP)</span><br><span class="line">                || firstTask !&#x3D; null</span><br><span class="line">                || workQueue.isEmpty()))</span><br><span class="line">            return false;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;检查工作线程数是否已经饱和</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            if (workerCountOf(c)</span><br><span class="line">                &gt;&#x3D; ((core ? corePoolSize : maximumPoolSize) &amp; COUNT_MASK))</span><br><span class="line">                return false;</span><br><span class="line">            &#x2F;&#x2F;成功就break了，走下面的逻辑了</span><br><span class="line">            if (compareAndIncrementWorkerCount(c))</span><br><span class="line">                break retry;</span><br><span class="line">            c &#x3D; ctl.get();</span><br><span class="line">            &#x2F;&#x2F; 再次检查工作线程数，工作线程数变化导致CAS失败的情况下重试内层的循环</span><br><span class="line">            if (runStateAtLeast(c, SHUTDOWN))</span><br><span class="line">                continue retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;用变量记录是否开启和添加成功</span><br><span class="line">    boolean workerStarted &#x3D; false;</span><br><span class="line">    boolean workerAdded &#x3D; false;</span><br><span class="line">    Worker w &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;Worker里调用了ThreadFactory的newThread，ThreadFactory封装了创建线程的参数</span><br><span class="line">        w &#x3D; new Worker(firstTask);</span><br><span class="line">        &#x2F;&#x2F;创建了线程</span><br><span class="line">        final Thread t &#x3D; w.thread;</span><br><span class="line">        if (t !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;获取全局锁</span><br><span class="line">            final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;再次检查，看线程池状态和线程的状态</span><br><span class="line">                int c &#x3D; ctl.get();</span><br><span class="line"></span><br><span class="line">                if (isRunning(c) ||</span><br><span class="line">                    (runStateLessThan(c, STOP) &amp;&amp; firstTask &#x3D;&#x3D; null)) &#123;</span><br><span class="line">                    &#x2F;&#x2F;再次检查线程的状态</span><br><span class="line">                    if (t.isAlive()) </span><br><span class="line">                        throw new IllegalThreadStateException();</span><br><span class="line">                    &#x2F;&#x2F;添加的工作线程集合中，方便管理</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    int s &#x3D; workers.size();</span><br><span class="line">                    if (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize &#x3D; s;</span><br><span class="line">                    workerAdded &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            if (workerAdded) &#123;</span><br><span class="line">                &#x2F;&#x2F;这里很重要，start启动的是worker线程，就是会调用worker的run方法</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F;线程没有启动成功，从workers中移除线程</span><br><span class="line">        if (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    return workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addWorker方法，总结一下就是添加工作线程，如果是新开的工作线程，会调用worker的run方法，这个调用很重要，具体看一下worker的run方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** Delegates main run loop to outer runWorker. *&#x2F;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        runWorker(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从注释可以知道，Worker类的run方法将操作委托给外部的ThreadPoolExecutor（Worker是ThreadPoolExecutor的内部类）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">    &#x2F;&#x2F;获取当前线程</span><br><span class="line">    Thread wt &#x3D; Thread.currentThread();</span><br><span class="line">    Runnable task &#x3D; w.firstTask;</span><br><span class="line">    w.firstTask &#x3D; null;</span><br><span class="line">    w.unlock(); &#x2F;&#x2F; allow interrupts</span><br><span class="line">    boolean completedAbruptly &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;不断的去取任务</span><br><span class="line">        while (task !&#x3D; null || (task &#x3D; getTask()) !&#x3D; null) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            &#x2F;&#x2F;池子状态stop了之后要中断线程</span><br><span class="line">            if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            try &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F;执行任务的run方法</span><br><span class="line">                    task.run();</span><br><span class="line">                    afterExecute(task, null);</span><br><span class="line">                &#125; catch (Throwable ex) &#123;</span><br><span class="line">                    afterExecute(task, ex);</span><br><span class="line">                    throw ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                task &#x3D; null;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly &#x3D; false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里写了个while循环去不断的取任务执行，我们再看一下getTask方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Runnable getTask() &#123;</span><br><span class="line">    boolean timedOut &#x3D; false; &#x2F;&#x2F; Did the last poll() time out?</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; ctl.get();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;不是running状态下的处理，返回null，runWorker方法的循环也就结束了</span><br><span class="line">        if (runStateAtLeast(c, SHUTDOWN)</span><br><span class="line">            &amp;&amp; (runStateAtLeast(c, STOP) || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int wc &#x3D; workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 是否要根据超时时间停止线程，核心线程也可以停止，需要根据allowCoreThreadTimeOut变量确定，像MonitorTask这种就会使用</span><br><span class="line">        boolean timed &#x3D; allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;处理停止线程</span><br><span class="line">        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;</span><br><span class="line">            if (compareAndDecrementWorkerCount(c))</span><br><span class="line">                return null;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;尝试从阻塞队列中获取任务</span><br><span class="line">        try &#123;</span><br><span class="line">            Runnable r &#x3D; timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            if (r !&#x3D; null)</span><br><span class="line">                return r;</span><br><span class="line">            timedOut &#x3D; true;</span><br><span class="line">        &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">            timedOut &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要是正常情况下，就会一直从队列里取任务出来执行。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>到这里，就可以得出线程池是怎么工作的，本质上就是通过线程不断的从阻塞队列中取出任务去执行。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式共识之Raft</title>
    <url>/2020/10/28/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E4%B9%8BRaft/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Raft是一个分布式共识协议。通过实现election（选举）和log replication（日志复制）实现共识。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>（1）每个结点只能有三种状态：follower，candidate，leader，且所有的结点初始化为follower。如果follower都不能接收到leader的心跳，他们就可以成为candidate。然后candidate向其他结点请求向自己投票。所有的结点都会响应投票，最终获得大多数投票的candidate会成为leader,这个过程叫做leader election（选举leader）。</p>
<p>（2）所有对系统的改变都会经过leader，每个改变都会当做一个entry写入leader结点的log中，要提交entry到log中必须满足结点先将entry复制到follower结点中。然后leader等待直到大多数的结点已经将entry写入log，然后entry就能够在leader结点上提交，然后leader通知所有的follower结点开始提交它们的entry到log中。如此这样的操作过程，整个集群就能够保持一致性，这个过程被称作log relipcation（日志复制）。</p>
<h2 id="选举的细节"><a href="#选举的细节" class="headerlink" title="选举的细节"></a>选举的细节</h2><p>（1）在Raft中，有两项超时设置来控制选举。第一项是选举超时，指的是一名follower等待成为candidate的时间，随机设置在150到300ms之间的值。选举超时后，follower成为candidate并开始新一轮的选举并给自己投上一票，然后给其他结点发送投票的信息，如果接收消息的结点在当前这一轮选举周期内没有投过票（注意新一轮选举周期的投票要重新算，即每个结点在每个周期都可以有一次投票机会），则投票给候选者。接着结点重置选举超时。一旦有一个candidate获得了大多数的投票，那么它将成为leader。</p>
<p>（2）follower成为leader后，就会开始发送追加entry消息到它的各个follower结点。这个消息会按照心跳超时的间隔进行发送，各个follower会响应每个消息，这就是第二项超时时间，心跳超时。leader的选举任期将会持续到有一个follower停止收到心跳（停止收到就是leader挂了，但是这里不是停止收到一次的意思，毕竟网络可能会有丢包，一般会设置心跳包次数，超过多少次才当做leader挂了）并成为candidate。</p>
<p>再讲一下超时时间的细节：这里是所有结点都设置选举时间，由于随机超时时间值不同，最后只有超时时间先到的结点成为candidate。极端条件下，有两个结点的随机超时时间值相同，那么可以通过拆分投票的方式，就是都成为candidate，看各个follower结点给两位candidate投票的情况。如果再次处于极端条件下，两个结点的投票相等，那么就会重新发起一次选举，重新走选举超时那一套逻辑。这种情况可以拓展为多个结点的情况。</p>
<h2 id="日志复制的细节"><a href="#日志复制的细节" class="headerlink" title="日志复制的细节"></a>日志复制的细节</h2><p>（1）日志复制通过使用与心跳消息类似的entry消息。</p>
<p>（2）当有新的改变尝试时会先经过leader，leader将改变追加到log中，然后将改变在下一次的心跳中发送给各个follower，当大多数的follower确认后就可以进行提交操作。</p>
<p>（3）在分区的情况下也能够达到共识。</p>
<p>假设有5个结点，leader为a，由于机房连通性问题，ab归为一个分区（leader为a，不用重新选），cde归为一个分区（leader为c，假设是重新选出来的，重新选，election term + 1），那么如果有客户端尝试对a和b分区的leader发起更新，由于结点数量只有2，没有达到大多数复制结点，则在ab的日志中是存在未提交状态的entry。如果有客户端尝试对cde的leader（c）发起更新，由于结点数量为3，达到大多数复制结点，则提交成功。后续，由于机房连通性问题解决后，结点通过对比term，term较低者下台（a下台），然后a与b回滚未提交的数据，并拉取leader（此时leader为c）的数据。</p>
<p>可能会有疑问：如果上面的例子，起始的leader为c，那么ab的分区就会重新选举，ecection term+1，而cde的leader不变。如果此时有客户端请求c进行了新的更改，在网络连通之后，因为a的term值较高，会将cde的数据抹去，这样岂不是将正常请求更新的数据删除了？</p>
<p>不会出现这种情况，因为ab分区的结点只有2个，不满足大多数，不能够选举成功。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://raft.github.io/raft.pdf" target="_blank" rel="noopener">paper</a></p>
<p><a href="https://raft.github.io/" target="_blank" rel="noopener">web site</a></p>
<p><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">animate</a></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>基于redis的分布式锁</title>
    <url>/2020/10/28/%E5%9F%BA%E4%BA%8Eredis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h3 id="单机下的分布式锁"><a href="#单机下的分布式锁" class="headerlink" title="单机下的分布式锁"></a>单机下的分布式锁</h3><p>setnx命令表示在set的时候判断值是否设置过，如果没有就设置并返回1，否则返回0。利用这个命令可以实现简单的分布式锁。业务开始执行获取锁，业务结束释放锁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;分布式的key，例如商品的话取业务+商品id组成key</span><br><span class="line">key &#x3D; lock_key</span><br><span class="line">try&#123;</span><br><span class="line">    &#x2F;&#x2F;获取锁</span><br><span class="line">    setnx key value</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;do something</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    &#x2F;&#x2F;释放锁</span><br><span class="line">    del key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式，可能存在业务执行过程中宕机了，导致del key没有执行，锁没有释放。可以加上超时时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;分布式的key，例如商品的话取业务+商品id组成key</span><br><span class="line">key &#x3D; lock_key</span><br><span class="line">try&#123;</span><br><span class="line">    &#x2F;&#x2F;获取锁</span><br><span class="line">    setnx key value</span><br><span class="line">    &#x2F;&#x2F;设置过期时间</span><br><span class="line">    expire key 30</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;do something</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    &#x2F;&#x2F;释放锁</span><br><span class="line">    del key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种设置过期的方式不是原子的，可能在setnx后宕机导致没有设置过期时间。redis的set可以同时设置ex和nx。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;分布式的key，例如商品的话取业务+商品id组成key</span><br><span class="line">key &#x3D; lock_key</span><br><span class="line">try&#123;</span><br><span class="line">    &#x2F;&#x2F;获取锁</span><br><span class="line">    set key value ex 30 nx</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;do something</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    &#x2F;&#x2F;释放锁</span><br><span class="line">    del key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式，可能由于任务超时，导致释放其他人的锁。例如jvm1机器获取到锁，超时时间设置为30s，但是由于任务执行过久超过30s锁自己释放了，此时jvm2机器获取到锁执行任务，但是jvm1机器的程序执行完开始释放锁，此时jvm3就可以获取锁，同一时刻有两个jvm在执行分布式的任务。可以设置key的value为独一无二的，例如UUID+ThreadId，在del的时候判断值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;分布式的key，例如商品的话取业务+商品id组成key</span><br><span class="line">key &#x3D; lock_key</span><br><span class="line">value &#x3D; uuid + threadId;</span><br><span class="line">try&#123;</span><br><span class="line">    &#x2F;&#x2F;获取锁</span><br><span class="line">    set key value ex 30 nx</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;do something</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    &#x2F;&#x2F;释放锁</span><br><span class="line">    if(get(key) &#x3D;&#x3D; value)&#123;</span><br><span class="line">        del key</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式会存在任务超时，锁就释放了，但是我的业务还没做完，并发下可能导致数据不一致，应该要等任务做完或者失败回滚后才能释放锁。可以采用守护线程定时续期的方式，假设jvm1设置的过期时间为30s，守护线程开启定时任务，假设是定时10s执行续期，如果宕机了，过期时间到也会执行自动释放锁。可以使用redisson，redisson底层也是用这种方式去实现的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;分布式的key，例如商品的话取业务+商品id组成key</span><br><span class="line">key &#x3D; lock_key</span><br><span class="line"></span><br><span class="line">redission &#x3D; Redission.getLock(key)</span><br><span class="line">&#x2F;&#x2F;获取锁</span><br><span class="line">redission.lock()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;do something</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;释放锁</span><br><span class="line">redission.unlock()</span><br></pre></td></tr></table></figure>

<p>redisson封装了适用于分布式锁的redis方法，原子操作基于lua脚本，redis会对lua脚本的命令执行类似数据库的事务，要么全部成功，要么全部失败，有失败回滚的操作（redis提供的multi等命令的事务操作是不会有失败回滚的）。redisson默认的锁过期时间为30s，开启守护线程每隔10s（10s是30除以3得到，其他时间以此类推）进行锁续期。</p>
<h3 id="集群下的分布式锁"><a href="#集群下的分布式锁" class="headerlink" title="集群下的分布式锁"></a>集群下的分布式锁</h3><p>假设集群模式下是一主多备，jvm1从主结点获取到锁，此时主结点未来得及同步到其他结点就挂了，挂了之后从备份结点选出新的主结点，此时jvm2从新的主结点就能够获取到锁。</p>
<p>为了解决上述的问题，redis引入了RedLock，采用多主的方式，工作方式如下：</p>
<p>（1）客户端以毫秒为单位获取当前时间</p>
<p>（2）尝试在所有N个实例中顺序获取锁，设置锁超时时间小于总释放时间，假设释放时间时间为10s，超时时间可能在5~50ms之间。如果获取失败，直接与下一个结点通信获取锁</p>
<p>（3）客户端通过当前时间减去（1）中获取的时间得到获取锁花费的时间。当且仅当大多数客户端（至少3个，且满足至少N/2+1个）获取锁，并且总的获取锁的时间小于锁有效时间，则认为获取了锁</p>
<p>（4）如果获取了锁，则将有效时间（3）中计算的时间</p>
<p>（5）如果不能够获取锁（无法锁定N/2+1个实例或者有效时间为负数），尝试解锁所有的实例。</p>
<p>RedLock参考自 <a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">redis官方</a>。</p>
]]></content>
      <categories>
        <category>分布式</category>
        <category>lock</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>lock</tag>
        <tag>分布式</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>有关IO</title>
    <url>/2020/11/16/%E6%9C%89%E5%85%B3IO/</url>
    <content><![CDATA[<h3 id="Java中的NIO与操作系统的NIO"><a href="#Java中的NIO与操作系统的NIO" class="headerlink" title="Java中的NIO与操作系统的NIO"></a>Java中的NIO与操作系统的NIO</h3><p>Java是New IO，操作系统是Non blocking Io。</p>
<p>Java中的NIO实际上是区分旧的IO，这里的N是指New，即NIO是New IO。NIO包下使用的IO是区分旧的BIO（Blocking IO），Non Blocking IO，调用的是操作系统提供的IO。看Java的源码可知，ServerSocketChannel.configureBlocking()方法是一个native方法，调用底层操作系统设置为非阻塞的IO。对应JDK中的ServerSocketChannel.accept()方法直接返回，如果没有返回null，有就返回socket（实际上是对应底层的fd）。以及SocketChannel.read()也是直接返回，如果没有返回-1，有就返回客户端目前传输的信息长度。</p>
<h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>IO多路复用是用来解决大量客户端连接，C10K这样的问题。C10K是假设有一万个客户端进行连接，那么在普通的Java NIO程序中，使用for循环进行系统调用遍历，那么每进行一次for循环就要进行一万次的系统调用，系统调用时间开销太大。解决思路就是想办法将一万次的系统调用合并为一次系统调用，这种解决的方法就是IO多路复用。</p>
<h5 id="同步IO多路复用："><a href="#同步IO多路复用：" class="headerlink" title="同步IO多路复用："></a>同步IO多路复用：</h5><p>select：传入fd数组，函数会遍历fd，返回数量（读fd的数量，写fd的数量），不会返回具体的fd。一般我们根据返回的数量判断是否要进行IO操作。fd数量限制在1024。</p>
<p><a href="https://man7.org/linux/man-pages/man2/select.2.html" target="_blank" rel="noopener">select参考手册</a></p>
<p>poll：与select基本无差，去除了1024的限制，是基于链表的实现。</p>
<p><a href="https://man7.org/linux/man-pages/man2/poll.2.html" target="_blank" rel="noopener">poll参考手册</a></p>
<p>epoll：基于事件订阅回调的实现，相比select和poll，时间复杂度降低为O(1)。而且epoll会在内核开辟空间保留fd。epoll会使用mmap加快内存与内核之间的数据搬运，具体是将fd集合存放在映射出来的内存，用户态每次直接从这块内存的中取fd进行读取即可。</p>
<p><a href="https://man7.org/linux/man-pages/man7/epoll.7.html" target="_blank" rel="noopener">epoll参考手册</a></p>
<p>本质上select，poll与epoll都是同步IO多路复用，同步是指函数都是返回了是否有IO准备就绪，当返回就绪了，依旧要自行遍历所有的fd将数据取出，遍历取数据过程仍然是同步阻塞的。</p>
<h5 id="异步IO多路复用："><a href="#异步IO多路复用：" class="headerlink" title="异步IO多路复用："></a>异步IO多路复用：</h5><p>Java 1.7版本引入了异步IO模型（AIO），底层通过线程池管理线程进行数据搬运，基于一种回调的机制进行操作。即等到数据搬运完成后回调通知处理，将搬运数据的操作委托给线程池。中间还使用了ReentrantReadWriteLock优化了读写。</p>
<h3 id="netty的选型"><a href="#netty的选型" class="headerlink" title="netty的选型"></a>netty的选型</h3><p>netty使用NIO模型，原因如下：</p>
<p>（1）linux没有很好的实现AIO，windows上的AIO实现很好，但是netty的开发人员并没有将windows认为是主流的服务器</p>
<p>（2）AIO需要预先分配内存空间，如果NIO是需要时才分配空间，这会造成AIO在流量很大但数据量很小的情况下出现内存浪费的问题</p>
]]></content>
      <categories>
        <category>IO</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-662</title>
    <url>/2020/12/16/leetcode-662/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p><a href="https://leetcode.com/problems/maximum-width-of-binary-tree/" target="_blank" rel="noopener">原题链接</a></p>
<h3 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h3><p>深度优先搜索，搜索过程带上深度和结点位置的信息，用哈希表记下深度以及最左侧结点的位置。每当遍历到任意的结点，将结点的位置减去结点所在层最左侧结点的位置，更新这个最大值。</p>
<h3 id="三、code"><a href="#三、code" class="headerlink" title="三、code"></a>三、code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    int ans;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map;</span><br><span class="line"></span><br><span class="line">    public int widthOfBinaryTree(TreeNode root) &#123;</span><br><span class="line">        ans &#x3D; 0;</span><br><span class="line">        map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        dfs(root, 0, 1);</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(TreeNode node, int pos, int depth) &#123;</span><br><span class="line">        if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map.putIfAbsent(depth, pos);</span><br><span class="line">        ans &#x3D; Math.max(ans, pos - map.get(depth) + 1);</span><br><span class="line">        dfs(node.left, pos * 2, depth + 1);</span><br><span class="line">        dfs(node.right, pos * 2 + 1, depth + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四、复杂度分析"><a href="#四、复杂度分析" class="headerlink" title="四、复杂度分析"></a>四、复杂度分析</h3><p>时间复杂度：O（n），遍历所有结点的消耗。</p>
<p>空间复杂度：O（log(n)），HashMap的存储的消耗，存储的数量为树的高度。</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>DMA与零拷贝</title>
    <url>/2020/10/29/DMA%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h1 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h1><h3 id="为什么要有DMA？"><a href="#为什么要有DMA？" class="headerlink" title="为什么要有DMA？"></a>为什么要有DMA？</h3><p>传统IO工作方式：</p>
<p>（1）用户调用read，向操作系统发起IO系统调用，接着CPU发送指令给磁盘控制器</p>
<p>（2）磁盘控制器收到指令，将数据放入磁盘控制器缓冲区，缓冲区满后产生中断信号</p>
<p>（3）CPU收到中断信号响应中断，将磁盘控制器缓冲区的数据拷贝到自己的寄存器，然后拷贝到内存中，数据在拷贝期间CPU无法执行其他任务</p>
<p><img src="https://cdn.jsdelivr.net/gh/fuxyzz/cdn/images/simple_io.png" alt="传统IO工作方式"></p>
<p>CPU在IO期间无法执行任务，降低了系统工作的整体性能，于是引入了DMA</p>
<h3 id="DMA概念及工作方式"><a href="#DMA概念及工作方式" class="headerlink" title="DMA概念及工作方式"></a>DMA概念及工作方式</h3><p>DMA全称Direct Memory Access，直译直接内存访问，作用是将CPU搬运数据的工作委托给DMA，解放CPU在数据搬运过程中的阻塞时间。具体工作方式如下：</p>
<p>（1）用户调用read，向操作系统发起IO系统调用，CPU将IO请求发送给DMA</p>
<p>（2）DMA收到指令后，将IO请求发送给磁盘</p>
<p>（3）磁盘收到IO请求后，将数据放入磁盘控制器缓冲区，缓冲区满后产生中断信号</p>
<p>（4）DMA响应中断信号，将磁盘缓冲区数据拷贝到内核缓冲区，缓冲区满后产生中断信号</p>
<p>（5）CPU响应中断信号，将内核缓冲区的数据拷贝到用户态缓冲区，系统调用返回</p>
<p><img src="https://cdn.jsdelivr.net/gh/fuxyzz/cdn/images/DMA_IO.png" alt="DMA工作方式"></p>
<h1 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h1><h3 id="常规的文件传输时的IO消耗"><a href="#常规的文件传输时的IO消耗" class="headerlink" title="常规的文件传输时的IO消耗"></a>常规的文件传输时的IO消耗</h3><p>基于DMA改进的IO方式在文件传输上发送4次内核态与用户态的切换，4次数据拷贝。</p>
<h5 id="4次内核态与用户态切换"><a href="#4次内核态与用户态切换" class="headerlink" title="4次内核态与用户态切换"></a>4次内核态与用户态切换</h5><p>（1）系统调用read，从用户态切换到内核态</p>
<p>（2）内核完成任务返回，从内核态切换到用户态</p>
<p>（3）系统调用write，从用户态切换到内核态</p>
<p>（4）内核完成任务返回，从内核态切换到用户态</p>
<h5 id="4次数据拷贝"><a href="#4次数据拷贝" class="headerlink" title="4次数据拷贝"></a>4次数据拷贝</h5><p>（1）DMA将磁盘数据拷贝到操作系统内核缓冲区</p>
<p>（2）CPU将内核缓冲区的数据拷贝到用户缓冲区</p>
<p>（3）CPU将用户缓冲区的数据拷贝到socket缓冲区</p>
<p>（4）DMA将socket缓冲区数据拷贝到物理网卡缓冲区</p>
<p>拷贝一份数据经过4次内核态与用户态的切换和4次的数据拷贝，在并发场景下这个IO消耗会被无限方法，考虑如何优化它。</p>
<h3 id="零拷贝对文件传输的优化思路"><a href="#零拷贝对文件传输的优化思路" class="headerlink" title="零拷贝对文件传输的优化思路"></a>零拷贝对文件传输的优化思路</h3><h4 id="mmap-write"><a href="#mmap-write" class="headerlink" title="mmap + write"></a>mmap + write</h4><p>mmap全称memory map，直译内存映射，作用是将内核缓冲区的数据映射到用户缓冲区，这样就不需要read，省去了一次数据拷贝，过程从read + write变为mmap + write。通过这种方式仍然需要4次上下文切换。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fuxyzz/cdn/images/mmap_write.png" alt="mmap + write"></p>
<h4 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h4><p>sendfile是linux 2.1版本中提供的函数，用于代替 read 和 write 2个系统调用，这样就减少了1次系统调用，2次上下文切换。sendfile提供的系统调用可以将内核缓冲区的数据之间拷贝到socket缓冲区。通过这种方式只有2次上下文切换和3次数据拷贝。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fuxyzz/cdn/images/sendfile_1.png" alt="sendfile1"></p>
<p>linux 2.4版本，如果网卡还支持SG—DMA（The Scatter-Gather Direct Memory Access），可以直接将内核缓冲区的数据直接拷贝到网卡的缓冲区。这样又减少了1次数据拷贝。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fuxyzz/cdn/images/sendfile_2.png" alt="sendfile2"></p>
<h4 id="零拷贝总结"><a href="#零拷贝总结" class="headerlink" title="零拷贝总结"></a>零拷贝总结</h4><p>零拷贝只有2次上下文切换和2次数据拷贝，数据拷贝是由DMA进行的，不需要经过CPU。</p>
<h2 id="零拷贝的缺点及解决方案"><a href="#零拷贝的缺点及解决方案" class="headerlink" title="零拷贝的缺点及解决方案"></a>零拷贝的缺点及解决方案</h2><p>零拷贝是基于PageCache，PageCache是磁盘高速缓存，也是我们上面说的内核缓冲区。PageCache是内存中的一部分，对应磁盘上的block，如果读取文件时在PageCache中命中则直接从内存读取，否则从磁盘中读取。PageCache内部使用LRU进行内存淘汰。由于PageCache本身不能太大，拷贝大文件的时候很容易出现PageCache的缓存命中率降低，甚至影响其他小文件的传输。在这种情况下，我们可以不使用基于PageCache的内核缓冲区，而是直接将磁盘的数据加载到用户缓冲区，这种方式称为直接IO，相对的使用PageCache的方式称为缓冲IO。</p>
<p>对于大文件，可以用异步IO + 直接IO（对于磁盘，异步IO只支持直接IO）的方式来解决：</p>
<p>（1）内核发起读请求，不等待数据拷贝完成就直接返回</p>
<p>（2）内核将数据拷贝到用户缓冲区后，通知进程处理数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/fuxyzz/cdn/images/aio.png" alt="aio"></p>
<h2 id="工程选型"><a href="#工程选型" class="headerlink" title="工程选型"></a>工程选型</h2><h5 id="小文件传输：零拷贝"><a href="#小文件传输：零拷贝" class="headerlink" title="小文件传输：零拷贝"></a>小文件传输：零拷贝</h5><h5 id="大文件传输：异步IO-直接IO"><a href="#大文件传输：异步IO-直接IO" class="headerlink" title="大文件传输：异步IO + 直接IO"></a>大文件传输：异步IO + 直接IO</h5><p>零拷贝在java nio，nginx和kafka都有使用。</p>
]]></content>
      <categories>
        <category>io</category>
      </categories>
      <tags>
        <tag>io</tag>
      </tags>
  </entry>
  <entry>
    <title>redis底层数据结构简介</title>
    <url>/2020/12/22/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>redis顶层的数据结构是hash，string，set，sorted set，list，底层是用dict，sds，ziplist，quicklist，skiplist等数据结构组合而成。</p>
<h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><p>dict是dictionary的简称，字典的意思，与Java中的HashMap类似，实现上有些许的区别。</p>
<p>dict中存在ht（hash table简称）数组，数组大小为2，索引0位为当前hash table，索引1位为正在进行重哈希的hash table（如果有正在进行的话），标识正在进行重哈希的变量是rehashidx，默认值为-1，没有进行重哈希，不为-1则是标识当前正在进行重哈希的位置。</p>
<p>redis将重哈希的操作分散到各个CRUD的操作中，每次CRUD的时候都将进行一部分的重哈希工作，具体是按空bucket来算工作量。例如每次重哈希的时候设定如果查找过程中遇到超过10个空bucket则本次工作结束。相对于Java中的HashMap，redis的重哈希似乎并没有将链表上的值进行再离散化。Java中HashMap的重哈希离散化如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;高位参与运算，使重哈希时有可能让链表分成两份</span><br><span class="line">hash &#x3D; (h &#x3D; key.hash) ^ (h &gt;&gt;&gt; 16)</span><br><span class="line">bucket &#x3D; hash &amp; (table - 1)</span><br></pre></td></tr></table></figure>

<p>dict处理哈希冲突的方式是链地址法，没有像Java的HashMap进行红黑树的优化。</p>
<p>dict使用MurmurHash2算法来计算bucket的key，算法的优点是输入的值是有规律的，算法仍然能给出一个较好的随机分布性（离散）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;整数hash</span><br><span class="line">unsigned int dictIntHashFunction(unsigned int key)</span><br><span class="line">&#123;</span><br><span class="line">    key +&#x3D; ~(key &lt;&lt; 15);</span><br><span class="line">    key ^&#x3D;  (key &gt;&gt; 10);</span><br><span class="line">    key +&#x3D;  (key &lt;&lt; 3);</span><br><span class="line">    key ^&#x3D;  (key &gt;&gt; 6);</span><br><span class="line">    key +&#x3D; ~(key &lt;&lt; 11);</span><br><span class="line">    key ^&#x3D;  (key &gt;&gt; 16);</span><br><span class="line">    return key;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;字符串hash</span><br><span class="line">unsigned int dictGenCaseHashFunction(const unsigned char *buf, int len) &#123;</span><br><span class="line">    unsigned int hash &#x3D; (unsigned int)dict_hash_function_seed;</span><br><span class="line">    while (len--)</span><br><span class="line">        hash &#x3D; ((hash &lt;&lt; 5) + hash) + (tolower(*buf++)); &#x2F;* hash * 33 + c *&#x2F;</span><br><span class="line">    return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dict重哈希的依据是 结点数 / 哈希表大小 &gt; 5。</p>
<h3 id="sds"><a href="#sds" class="headerlink" title="sds"></a>sds</h3><p>sds全称simple dynamic string，redis实现的sds是可动态拓展的，而且二进制安全。</p>
<p>redis的实现中，分为两种字符串，一种是静态不变的sdshr5（可存动态的，只是容量小，而且会引发内存重新分配），一种是可变的（有多个，sdshr8，sdshr16，sdshr32，sdshr64，区别是最大长度不一样）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __attribute__ ((__packed__)) sdshdr5 &#123;</span><br><span class="line">    unsigned char flags; &#x2F;* 3 lsb of type, and 5 msb of string length *&#x2F;</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;;</span><br><span class="line">struct __attribute__ ((__packed__)) sdshdr8 &#123;</span><br><span class="line">    uint8_t len; &#x2F;* used *&#x2F;</span><br><span class="line">    uint8_t alloc; &#x2F;* excluding the header and null terminator *&#x2F;</span><br><span class="line">    unsigned char flags; &#x2F;* 3 lsb of type, 5 unused bits *&#x2F;</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;;</span><br><span class="line">struct __attribute__ ((__packed__)) sdshdr16 &#123;</span><br><span class="line">    uint16_t len; &#x2F;* used *&#x2F;</span><br><span class="line">    uint16_t alloc; &#x2F;* excluding the header and null terminator *&#x2F;</span><br><span class="line">    unsigned char flags; &#x2F;* 3 lsb of type, 5 unused bits *&#x2F;</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;;</span><br><span class="line">struct __attribute__ ((__packed__)) sdshdr32 &#123;</span><br><span class="line">    uint32_t len; &#x2F;* used *&#x2F;</span><br><span class="line">    uint32_t alloc; &#x2F;* excluding the header and null terminator *&#x2F;</span><br><span class="line">    unsigned char flags; &#x2F;* 3 lsb of type, 5 unused bits *&#x2F;</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;;</span><br><span class="line">struct __attribute__ ((__packed__)) sdshdr64 &#123;</span><br><span class="line">    uint64_t len; &#x2F;* used *&#x2F;</span><br><span class="line">    uint64_t alloc; &#x2F;* excluding the header and null terminator *&#x2F;</span><br><span class="line">    unsigned char flags; &#x2F;* 3 lsb of type, 5 unused bits *&#x2F;</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不变的sds使用flags的低三位标识类型，高5位标识长度。</p>
<p>可变的sds使用len标识长度，alloc标识最大可分配长度，flags使用低3位标识类型。当字符串变化时，如果长度超过buff一开始分配的空间大小则会重新分配内存，如果长度超过alloc可表示的最大值则会更换类型（例如sdshr32 -&gt; sdshr64）。当已有字符串的时候，buff数组在申请的时候会申请更多的空间，方便后续追加。</p>
<h3 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h3><p>ziplist直译是压缩表，说到表很容易想到的是哈希表，redis中的hash是ziplist和dict两种方案结合实现，在数据较小的情况下位ziplist，在数据量达到一定条件的情况下会转成dict。</p>
<p>ziplist的结构大致如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;zlbytes&gt;&lt;zltail&gt;&lt;zllen&gt;&lt;entry&gt;...&lt;entry&gt;&lt;zlend&gt;</span><br></pre></td></tr></table></figure>

<p>zlibytes：32bit，表示ziplist占用的总字节数（包括zlibytes本身）</p>
<p>zltail：32bit，表示最后一个entry相对偏移字节数。方便在队尾push和pop。</p>
<p>zllen：16bit，表示entry的数量。只有16bit，最大表示 2<sup>16</sup> - 1。当zllen值在小于等于 2<sup>16</sup> - 2时，zllen表示entry的数量；当zllen值等于2<sup>16</sup> - 1时，标识zllen已无法表示entry的数量，ziplist会使用遍历ziplist的方式统计entry的数量。</p>
<p>entry：数据项。</p>
<p>zlend：ziplist的最后1个字节，标识结束，值为255。</p>
<p>从ziplist使用相对偏移的方式寻址说明redis希望使用内存紧凑的方式来尽可能的消除内存碎片（使用连续分配的内存）。但是这种方式带来的代价就是在增删改的时候可能会造成如果需要内存增加的时候后面的内存已经被占用，为了还是用内存紧凑的方式，需要重新分配内存，而且要大规模的迁移数据，所以ziplist在相对数据较少的情况下使用（数据少时进行迁移数据也少，但这并不意味着redis在较少数据下使用ziplist是因为效率比dict高，更多的是空间上的考虑，空间换时间减少内存碎片）。</p>
<p>满足以下任一条件，hash底层从ziplist转为dict：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;file-value超过512，或者说ziplist的entry超过1024</span><br><span class="line">hash-max-ziplist-entries &#x3D; 512</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;插入的value长度超过64</span><br><span class="line">hash-max-ziplist-value &#x3D; 64</span><br></pre></td></tr></table></figure>

<p>再说hash-max-ziplist-entries，因为ziplist实现hash的时候采用field-value相连的方式，存储两个entry，第一个为field，第二个为value。因为前面有zlibytes，zltail，zllen，第一个entry是第4位，存filed，第5个entry存value，以此类推，偶数项存field，奇数项存value。</p>
<h3 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h3><p>quicklist是redis提供的list的底层实现。quicklist可以理解为Java中的LinkedList，使用链表的方式进行实现，中间的结点用ziplist辅助实现。</p>
<p>使用ziplist作为结点辅助的理由：</p>
<p>（1）quicklist为了支持在两端进行快速的push和pop，需要在每个结点上增加两个额外的指针保存头和尾</p>
<p>（2）结点过多容易造成内存碎片</p>
<p>（3）ziplist不造成内存碎片，但是有重新分配内存的情况</p>
<p>因此quicklist结合双向链表和ziplist的优点，并提供进阶配置对ziplist进行定制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">* 值为正表示按entry数限制ziplist长度</span><br><span class="line">* 值为负时：</span><br><span class="line">* -5，每个ziplist不能超过64Kb</span><br><span class="line">* -4，每个ziplist不能超过32Kb</span><br><span class="line">* -3，每个ziplist不能超过16Kb</span><br><span class="line">* -2，每个ziplist不能超过8Kb（默认值）</span><br><span class="line">* -1，每个ziplist不能超过4Kb</span><br><span class="line">*&#x2F;</span><br><span class="line">list-max-ziplist-size &#x3D; -2</span><br></pre></td></tr></table></figure>

<p>quicklist大概长这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;prePoint&gt;&lt;ziplist&gt;&lt;nextPoint&gt;...&lt;prePoint&gt;&lt;ziplist&gt;&lt;nextPoint&gt;</span><br></pre></td></tr></table></figure>

<p>我们可以认为一个 <prePoint><ziplist><nextPoint> 是一个quicklistNode。</p>
<p>quicklist有两个指针head和tail分别指向头部的quicklistNode和尾部的quicklistNode。</p>
<h3 id="skiplist"><a href="#skiplist" class="headerlink" title="skiplist"></a>skiplist</h3><p>skiplist的结构如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fuxyzz/cdn/images/skiplist.png" alt="skiplist"></p>
<p>skiplist是空间和时间上的折中做法。相比哈希表，哈希表能够O（1）时间内查询，但是会浪费空间。相比平衡树，两者的查找时间都是O（log n），但是skiplist的平均指针数会更少，这取决于生成单个结点的层数。</p>
<p>单个结点生成的层数的计算依赖两个变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p &#x3D; 1&#x2F;4</span><br><span class="line">maxLevel &#x3D; 32</span><br></pre></td></tr></table></figure>
<p>计算函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int getLevel()&#123;</span><br><span class="line">    int level &#x3D; 1;</span><br><span class="line">    while Math.random() &lt; p &amp;&amp; level &lt; maxLevel &#123;</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从skiplist的结构上可以看出，skiplist无法满足zset中的一些操作，例如根据data获取score，所以还用了dict辅助。在数据量较少的情况下，zset是用ziplist实现的，数据量达到一定时，用skiplist和dict实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;score 和 member的存储对数量超过这个值就转成skiplist 和 dict</span><br><span class="line">zset_max_ziplist_entries &#x3D; 128</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;任意一个插入的member存储占用超过这个值就转成skiplist 和 dict</span><br><span class="line">zset-max-ziplist-value &#x3D; 64</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Reactor模型</title>
    <url>/2021/01/04/Reactor%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><img src="https://cdn.jsdelivr.net/gh/fuxyzz/cdn/images/bio-handler.png" alt=""></p>
<p>传统BIO方式的网络连接处理：客户端发起请求，服务器accept一个请求，经过读取，解码，计算，编码，发送等过程，完成一次请求的处理。这个过程中，accept如果阻塞了，会导致后面的请求也被阻塞。</p>
<p>为了解决BIO引起的IO阻塞问题，提出了NIO。NIO的主要工作方式是无论IO有没有准备就绪，都会直接返回结果，不阻塞，具体由操作系统底层实现的select、poll、epoll完成。基于NIO，我们可以实现高性能的网络处理，一种有效的模型就是Reactor。</p>
<p>Reactor应用于网络高性能框架中，Redis，Netty中都有它的身影。</p>
<h3 id="Reactor模型中的相关组件"><a href="#Reactor模型中的相关组件" class="headerlink" title="Reactor模型中的相关组件"></a>Reactor模型中的相关组件</h3><p><img src="https://cdn.jsdelivr.net/gh/fuxyzz/cdn/images/event-in-awt.png" alt=""></p>
<p>了解AWT，写过桌面端或者客户端（Java的GUI，Android等）的同学会很熟悉这张图，基于事件响应的模型。用户发生click动作，产生相应的事件，事件会传播给对应注册了监听事件的组件进行处理，运用了观察者模式。Reactor与这种模式是很类似的。</p>
<p>Reactor：负责响应IO事件，转发事件到相应的handler。类似AWT线程。</p>
<p>handler：类似图中的button调用addActionListener方法进行监听注册，将handler与事件绑定，等待事件就绪后进行处理。我们可以当他是一个Worker。</p>
<h3 id="单Reactor单Handler下的Reactor模型"><a href="#单Reactor单Handler下的Reactor模型" class="headerlink" title="单Reactor单Handler下的Reactor模型"></a>单Reactor单Handler下的Reactor模型</h3><p><img src="https://cdn.jsdelivr.net/gh/fuxyzz/cdn/images/single-thread-reactor.png" alt=""></p>
<p>如图所示，其中的acceptor是Reactor中注册了accept的IO事件，用于处理建立连接的。相当于一个Reactor线程处理连接，一个Hanlder线程处理读，解码，计算，解码，发送。</p>
<h3 id="单Reactor多Handler模型"><a href="#单Reactor多Handler模型" class="headerlink" title="单Reactor多Handler模型"></a>单Reactor多Handler模型</h3><p><img src="https://cdn.jsdelivr.net/gh/fuxyzz/cdn/images/multi-thread-worker.png" alt=""></p>
<p>如图所示，是一个多Handler的模型，用线程池管理Handler线程。同时，Hanlder也不再负责有关读写的操作，即不负责处理IO读写，只做解码，计算，编码的操作。read和send交给Reactor做。</p>
<h3 id="多Reactor多Handler模型"><a href="#多Reactor多Handler模型" class="headerlink" title="多Reactor多Handler模型"></a>多Reactor多Handler模型</h3><p><img src="https://cdn.jsdelivr.net/gh/fuxyzz/cdn/images/multi-thread-reactor.png" alt=""></p>
<p>如图所示，有一个主Reactor，接受请求后将读写的处理交由子Reactor操作，这样就提高了对CPU的利用率。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="noopener">Doug Lea的有关nio的文章</a></p>
<p><a href="https://cdn.jsdelivr.net/gh/fuxyzz/cdn/files/nio.pdf" target="_blank" rel="noopener">备用</a></p>
]]></content>
      <categories>
        <category>nio</category>
        <category>Reactor</category>
      </categories>
      <tags>
        <tag>nio</tag>
        <tag>Reactor</tag>
      </tags>
  </entry>
</search>
